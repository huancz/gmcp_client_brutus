<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Save on Wednesday, September 01, 2010, 4:37 PM -->
<!-- MuClient version 4.59 -->

<!DOCTYPE muclient [
   <!ENTITY show_vnums "true" >
   <!ENTITY show_timing "false" >
   <!ENTITY show_completed "true" >
   <!ENTITY show_database_mods "false" >
   <!ENTITY show_other_areas "false" >
   <!ENTITY show_area_exits "false" >
   <!ENTITY show_up_down "false" >
   <!ENTITY speedwalk_prefix "" >
]>

<muclient>
<plugin
   name="brutus_mapper"
   author="Multiple"
   id="b6eae87ccedd84f510b74714"
   language="Lua"
   purpose="Draws GMCP map for BRUTUSmud"
   date_written="2010-09-01 16:37:14"
   requires="4.73"
   version="2.0"
   save_state="y"
   >

<description trim="y">
<![CDATA[
AUTOMATIC MAPPER by Fiendish
** This is a very improved GMCP version of the original ATCP mapper by Nick Gammon.
** Some GMCP specific code added by Lasher.
** A few new features contributed by Spartacus.
** Many bugs squashed and major improvements made to the original design by Fiendish.

The window can be dragged to a new location by dragging the room name.
Your current room is always in the center with a bolder border.
LH-click on a room to speed-walk to it. RH-click on a room for options.

LH-click on the "*" button on the upper-left corner for configuration settings.
(click again on the [x] to close configuration)
]]>
</description>
</plugin>

<!--  Timers  -->

<timers>
<timer
   name="backup_timer"
   enabled="y"
   script="automatic_backup"
   hour="23" minute="59" second="59"
   active_closed="y" >
</timer>
</timers>

<aliases>

<alias
   match="mapper showroom *"
   enabled="y"
   script="draw_other"
   sequence="100"
></alias>

<alias
   match="mapper backup"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="manual_backup"
></alias>

<alias
   match="mapper backups*"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   send_to="12"
>
<send>
   if "%1" == " off" then
      EnableTimer("backup_timer", false)
      SetVariable("backup_timer_enabled", "0")
      Note("Automated map database backup is now off.")
   elseif "%1" == " on" then
      EnableTimer("backup_timer", true)
      SetVariable("backup_timer_enabled", "1")
      Note("Automated map database backup is now on.")
      if ((os.time()-last_auto_backup) >= 86401) then
         Note("It looks like it has been more than 24 hours since your last automatic mapper database backup!")
         Note("Forcing an automatic backup now...")
         Note("")
         Repaint()
         automatic_backup()
      end
   elseif "%1" == "" then
      Note("Automated map database backup is currently "..((GetTimerInfo("backup_timer", 6) and "on") or "off")..".")
      local will_be_would_be = ((GetTimerInfo("backup_timer", 6) and "will be") or "would be (if enabled)")
      local seconds = GetTimerInfo("backup_timer", 13)
      local hours = math.floor(seconds/3600)
      seconds = seconds - hours*3600
      local minutes = math.floor(seconds/60)
      seconds = math.floor(seconds - minutes*60)
      Note("Next backup "..will_be_would_be.." in "..hours.." hours, "..minutes.." minutes, "..seconds.." seconds.")
      Note("Backup compression is currently "..(((use_compression == 1) and "enabled.") or "disabled."))
   elseif "%1" == " compressed" then
      use_compression = 1
      SetVariable("use_compression", use_compression)
      Note("Mapper backups will be compressed. This will make backups take a few seconds longer but save a bit of space.")
   elseif "%1" == " uncompressed" then
      use_compression = 0
      SetVariable("use_compression", use_compression)
      Note("Mapper backups will not be compressed. This will make backups faster but take up a bit more space.")
   else
      Note("Invalid option for mapper backups. The current automated backup setting is '"..((GetTimerInfo("backup_timer", 6) and "on") or "off").."'. Try 'mapper backups on' or 'mapper backups off' to set your desired preference.")
   end
</send>
</alias>

<alias
   match="resetlayout"
   enabled="y"
   sequence="100"
   ignore_case="y"
   script="reset_aard"
></alias>

<alias
   match="^mapper quicklist( (on|off))?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="quick_mode_toggle"
></alias>

<alias
   match="^mapper shownotes( (on|off))?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="shownote_toggle"
></alias>

<alias
   match="mapper zoom out"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="mapper.zoom_out"
></alias>

<alias
   match="mapper zoom in"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="mapper.zoom_in"
></alias>

<alias
   match="mapper lockexit"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   send_to="12"
><send>
   room_lock_exit()
</send>
</alias>

<alias
   match="mapper findpath * *"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="findpathfast"
></alias>

<alias
   match="mapper find *"
   enabled="y"
   sequence="100"
   script="map_find"
   regexp="n"
></alias>

<alias
   match="^mapper shops?( .+)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="map_shops"
></alias>

<alias
   match="^mapper train( .+)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="map_trainers"
></alias>

<alias
   match="^mapper quest( .+)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="map_quests"
></alias>

<alias
   match="^mapper heal( .+)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="map_healers"
></alias>

<alias
   match="mapper goto *"
   enabled="y"
   sequence="100"
   script="map_goto"
></alias>

<alias
   match="mapper walkto *"
   enabled="y"
   sequence="100"
   script="map_goto"
></alias>

<alias
   match="mapper where *"
   enabled="y"
   sequence="100"
   script="map_where"
></alias>

<alias
   match="mapper thisroom"
   enabled="y"
   sequence="100"
   script="show_this_room"
   regexp="n"
></alias>

<alias
   match="mapper unmapped *"
   enabled="y"
   sequence="100"
   script="show_known_unmapped_exits"
   regexp="n"
></alias>

<alias
   match="mapper unmapped"
   enabled="y"
   sequence="100"
   script="show_known_unmapped_exits"
   regexp="n"
></alias>

<alias
   match="^mapper notes( (.+))?$"
   enabled="y"
   regexp="y"
   sequence="100"
   script="map_notes"
></alias>

<alias
   match="mapper bookmarks"
   enabled="y"
   sequence="100"
   script="map_notes"
></alias>

<alias
   match="mapper purgezone*"
   enabled="y"
   sequence="100"
   script="map_purgezone"
></alias>

<alias
   match="mapper purgeroom"
   enabled="y"
   sequence="100"
   send_to="12"
><send>
   if not current_room then
      print ("PURGEROOM FAILED: No room received from the mud yet. Try using the 'LOOK' command first.")
   else
      map_purgeroom(current_room)
      mapper.draw (current_room)
   end
</send>
</alias>

<alias
   match="mapper clearcache"
   enabled="y"
   sequence="100"
   script="map_clearcache"
></alias>

<alias
   match="mapper resume"
   enabled="y"
   sequence="100"
   script="map_resume"
></alias>

<alias
   match="mapper stop"
   enabled="y"
   sequence="100"
   script="mapper.cancel_speedwalk"
></alias>

<alias
   match="mapper hide"
   enabled="y"
   sequence="100"
   script="mapper.hide"
></alias>

<alias
   match="mapper show"
   enabled="y"
   sequence="100"
   script="mapper.show"
></alias>

<alias
   match="mapper area *"
   enabled="y"
   sequence="100"
   script="map_area"
   regexp="n"
></alias>

<alias
   match="mapper list *"
   enabled="y"
   sequence="100"
   script="map_list"
   regexp="n"
></alias>

<alias
   match="mapper next"
   enabled="y"
   sequence="100"
   script="mapper.gotoNextResult"
   regexp="n"
></alias>

<alias
   match="^mapper portals$"
   enabled="y"
   sequence="100"
   script="map_portal_list"
   regexp="y"
></alias>

<alias
   match="^mapper portal (.+)$"
   enabled="y"
   sequence="100"
   script="map_portal"
   regexp="y"
></alias>

<alias
   match="^mapper delete portal (.+)$"
   enabled="y"
   sequence="100"
   script="map_portal_delete"
   regexp="y"
></alias>

<alias
   match="mapper portalrecall *"
   enabled="y"
   sequence="100"
   script="map_portal_recall"
   regexp="n"
></alias>

<alias
   match="mapper portallevel *"
   enabled="y"
   sequence="100"
   script="map_portal_level"
   regexp="n"
></alias>

<alias
   match="^mapper delete cexits$"
   enabled="y"
   sequence="100"
   script="map_cexits_delete"
   regexp="y"
></alias>

<alias
   match="^mapper purge portals$"
   enabled="y"
   sequence="100"
   regexp="y"
   send_to="12"
>
<send>
   Note("Are you sure you want to purge all portal exits? To confirm type 'mapper purge portals confirm'.")
   toConfirm = "purge portals"
   EnableAlias("confirm_catch", true)
</send>
</alias>

<alias
   match="^mapper purge cexits$"
   enabled="y"
   sequence="100"
   regexp="y"
   send_to="12"
>
<send>
   Note("Are you sure you want to purge all custom mapper exits? To confirm type 'mapper purge cexits confirm'.")
   toConfirm = "purge cexits"
   EnableAlias("confirm_catch", true)
</send>
</alias>

<alias
   match="^(.*)$"
   enabled="n"
   name="confirm_catch"
   keep_evaluating="n"
   sequence="1"
   regexp="y"
   send_to="12"
>
<send>
   if "%1" == "mapper purge cexits confirm" and toConfirm == "purge cexits" then
      map_cexits_purge()
   elseif "%1" == "mapper purge portals confirm" and toConfirm == "purge portals" then
      map_portal_purge()
   else
      Note(string.format("Failed to confirm '%s'. Aborting.", toConfirm))
   end
   toConfirm = ""
   EnableAlias("confirm_catch", false)
</send>
</alias>

<alias
   match="mapper cexits *"
   enabled="y"
   sequence="100"
   script="custom_exit_list"
   regexp="n"
></alias>

<alias
   match="mapper cexits"
   enabled="y"
   sequence="100"
   script="custom_exit_list"
   regexp="n"
></alias>

<alias
   match="^mapper cexit (.+)$"
   enabled="y"
   sequence="100"
   script="custom_exit"
   regexp="y"
></alias>

<alias
   match="^mapper cexit_wait (.+)$"
   enabled="y"
   sequence="100"
   script="change_cexit_delay"
   regexp="y"
></alias>

<alias
   match="mapper areas"
   enabled="y"
   sequence="100"
   script="map_areas"
></alias>

<alias
   match="mapper areas *"
   enabled="y"
   sequence="100"
   script="map_areas"
></alias>

<alias
   match="^mapper addnote( .*)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   send_to="12"
>
<send>
   room_edit_note(nil,nil,Trim("%1"))
</send>
</alias>

<alias
   match="^mapper bounceportal( .*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   script="map_bounceportal"
></alias>

<alias
   match="^mapper bouncerecall( .*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   script="map_bouncerecall"
></alias>

<alias
   match="^mapper help( (.*))?$"
   enabled="y"
   regexp="y"
   script="OnHelp"
></alias>

</aliases>

<triggers>

<trigger
   enabled="y"
   match="The door is locked."
   script="mapper.cancel_speedwalk"
   sequence="100"
></trigger>

<trigger
   enabled="y"
   match="You are regaining balance and are unable to move."
   script="mapper.cancel_speedwalk"
   sequence="100"
></trigger>

<trigger
   enabled="y"
   match="You fumble about drunkenly."
   script="mapper.cancel_speedwalk"
   sequence="100"
></trigger>

<trigger
   enabled="y"
   match="You must be standing first."
   script="mapper.cancel_speedwalk"
   sequence="100"
></trigger>

<trigger
   enabled="y"
   match="You need to use a boat, fly, or swim underwater to go there."
   script="mapper.cancel_speedwalk"
   sequence="100"
></trigger>

<trigger
   enabled="y"
   match="You can't * while sitting."
   script="mapper.cancel_speedwalk"
   sequence="100"
></trigger>

<trigger
   enabled="y"
   regexp="y"
   match="^You dream about "
   script="mapper.cancel_speedwalk"
   sequence="100"
></trigger>

<trigger
   enabled="y"
   match="There is no exit in that direction."
   script="mapper.cancel_speedwalk"
   sequence="100"
></trigger>

<trigger
   enabled="y"
   match="Alas, you cannot go that way."
   script="mapper.cancel_speedwalk"
   sequence="100"
></trigger>

  <trigger
   enabled="y"
   match="^Magic walls bounce you back\.$"
   regexp="y"
   script="noportal_room"
   sequence="100"
  >
  </trigger>

  <trigger
   enabled="y"
   match="^You cannot (recall|return home) from this room\.$"
   regexp="y"
   script="norecall_room"
   sequence="100"
  >
  </trigger>

</triggers>

<script>

local show_vnums = &show_vnums;
local show_timing = &show_timing;
local show_completed = &show_completed;
local show_database_mods = &show_database_mods;
local show_other_areas = &show_other_areas;
local show_up_down = &show_up_down;
local show_area_exits = &show_area_exits;
local speedwalk_prefix = "&speedwalk_prefix;"

<![CDATA[

require "serialize"
mapper = require "brutusmapper"
require "gmcphelper"
require "tprint"
require "wait"

toConfirm = ""

-- Mapper Variables --

default_config = {
   -- assorted colours
   BACKGROUND_COLOUR       = { name = "Area Background",        colour =  ColourNameToRGB "#111111", },
   ROOM_COLOUR             = { name = "Room",              colour =  ColourNameToRGB "#dcdcdc", },
   EXIT_COLOUR             = { name = "Exit",              colour =  ColourNameToRGB "#e0ffff", },
   EXIT_COLOUR_UP_DOWN     = { name = "Exit up/down",      colour =  ColourNameToRGB "#ffb6c1", },
   ROOM_NOTE_COLOUR        = { name = "Room notes",       colour =  ColourNameToRGB "lightgreen", },
   OUR_ROOM_COLOUR         = { name = "Our room",          colour =  ColourNameToRGB "#ff1493", },
   UNKNOWN_ROOM_COLOUR     = { name = "Unknown room",      colour =  ColourNameToRGB "#8b0000", },
   DIFFERENT_AREA_COLOUR   = { name = "Another area",      colour =  ColourNameToRGB "#ff0000", },
   PK_BORDER_COLOUR        = { name = "PK border",         colour =  ColourNameToRGB "red", },
   SHOP_FILL_COLOUR        = { name = "Shop",              colour =  ColourNameToRGB "#ffad2f", },
   HEALER_FILL_COLOUR      = { name = "Healer",       colour =  ColourNameToRGB "#9acd32", },
   TRAINER_FILL_COLOUR     = { name = "Trainer",       colour =  ColourNameToRGB "#9acd32", },
   QUESTOR_FILL_COLOUR     = { name = "Questor",       colour =  ColourNameToRGB "deepskyblue", },
   BANK_FILL_COLOUR        = { name = "Bank",              colour =  ColourNameToRGB "#ffD700", },
   GUILD_FILL_COLOUR        = { name = "Guild",              colour =  ColourNameToRGB "magenta", },
   SAFEROOM_FILL_COLOUR    = { name = "Safe room",          colour =  ColourNameToRGB "lightblue", },
   MAPPER_NOTE_COLOUR      = { name = "Messages",          colour =  ColourNameToRGB "lightgreen" },

   ROOM_NAME_TEXT          = { name = "Room name text",    colour = ColourNameToRGB "#BEF3F1", },
   ROOM_NAME_FILL          = { name = "Room name fill",    colour = ColourNameToRGB "#105653", },
   ROOM_NAME_BORDER        = { name = "Room name box",     colour = ColourNameToRGB "black", },

   AREA_NAME_TEXT          = { name = "Area name text",    colour = ColourNameToRGB "#BEF3F1",},
   AREA_NAME_FILL          = { name = "Area name fill",    colour = ColourNameToRGB "#105653", },
   AREA_NAME_BORDER        = { name = "Area name box",     colour = ColourNameToRGB "black", },

   FONT = { name =  get_preferred_font {"Dina",  "Lucida Console",  "Fixedsys", "Courier",} ,
            size = 8
         } ,

   -- size of map window
   WINDOW = { width = mapper.default_width, height = mapper.default_height },

   -- how far from where we are standing to draw (rooms)
   SCAN = { depth = 300 },

   -- show custom tiling background textures
   USE_TEXTURES = { enabled = true },

   -- how many seconds to show "recent visit" lines (default 3 minutes)
   LAST_VISIT_TIME = { time = 60 * 3 },

}

mylevel = 0
mytier = 0
use_compression = tonumber(GetVariable("use_compression") or 0)
quick_mode = (GetVariable("quick_mode") == "1")
shownotes = ((GetVariable("shownotes") or "1") == "1") -- default true
local rooms = {}
local areas = {}
local environments = {}
local user_terrain_colour = {}
local in_backup = false

room_not_in_database = {}
room_in_database = {}

bounce_recall = nil
bounce_portal = nil

-- Create Database Variables --

count = 0
roomcount = 0
endroomcount = 0
areacount = 0
coordcount = 0
directioncount = 0
environmentcount = 0

directions = {}

function reset_aard()
   mapper.reset_pos()
   OnPluginSaveState()
   OnPluginInstall()
end

convert_direction = {
   north = "n",
   south = "s",
   east = "e",
   west = "w",
   up = "u",
   down = "d"
}

function dbcheck (code, query)
   if code ~= sqlite3.OK and    -- no error
      code ~= sqlite3.ROW and   -- completed OK with another row of data
      code ~= sqlite3.DONE then -- completed OK, no more rows
         local err = db:errmsg ()  -- the rollback will change the error message
         err = err.."\n\nCODE: "..code.."\nQUERY: "..query.."\n"
         db:exec ("ROLLBACK")      -- rollback any transaction to unlock the database
         error (err, 3)            -- show error in caller's context
   end -- if
end -- dbcheck

function fixsql (s)
   if s then
      return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
   else
      return "NULL"
   end -- if
end -- fixsql

function fixbool (b)
   if b then
      return 1
   else
      return 0
   end -- if
end -- fixbool

function findpathfast(name, line, wildcards)
   db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
   local foundpath = findpath(tonumber(wildcards[1]),tonumber(wildcards[2]))
   if foundpath == nil then
      mapper.mapprint (string.format ("Path from %s to %s not found.", wildcards[1], wildcards[2]))
      return
   end

   -- turn into speedwalk
   local speedwalk = mapper.build_speedwalk (foundpath, speedwalk_prefix)

   -- display it
   if speedwalk ~= nil then
      mapper.mapprint (string.format ("Path from %s to %s is: %s", wildcards[1], wildcards[2], speedwalk))
   else
      mapper.mapprint ("Pick different start and end rooms.")
   end
end

function map_bounceportal (name, line, wildcards)
   wildcards[1] = Trim(wildcards[1])
   if wildcards[1]=="" then
      if bounce_portal and bounce_portal.dir then
         Note("\nBOUNCEPORTAL: Currently set to '"..bounce_portal.dir.."'")
      else
         Note("\nBOUNCEPORTAL: Not currently set.")
      end
      return
   elseif wildcards[1]=="clear" then
      bounce_portal = nil
      Note("\nBOUNCEPORTAL: cleared.")
      dbCheckExecute(string.format("DELETE from storage where name is %s;", fixsql("bounce_portal")))
      return
   end

   local pnum = tonumber(wildcards[1])

   if pnum==nil then
      Note("\nBOUNCEPORTAL FAILED: The required parameter for mapper bounceportal is <portal_index>. Current portal indexes can be found in the 'mapper portals' output.\n")
      return
   end

   local q = "select area, name, touid, fromuid, dir, exits.date_added, exits.level from exits,rooms where exits.touid=rooms.uid and exits.fromuid in ('*','**') order by area,touid"
   local count = 1
   local found = false
   for row in db:nrows(q) do
      if count == pnum then
         if row.fromuid == "*" then
            bounce_portal = {dir=row.dir, uid=row.touid}
            Note("\nBOUNCEPORTAL: Set portal #"..count.." ("..row.dir..") as the bounce portal for portal-friendly norecall rooms.")
            dbCheckExecute(string.format("INSERT OR REPLACE INTO storage (name, data) VALUES (%s,%s);", fixsql("bounce_portal"), fixsql(serialize.save("bounce_portal"))))
         else
            Note("\nBOUNCEPORTAL FAILED: Portal #"..pnum.." is a recall portal. You must choose a mapper portal that does not use either the recall or home commands for the bounce portal.")
         end
         found = true
      end
      count = count + 1
   end
   if found == false then
      Note(string.format("\nBOUNCEPORTAL FAILED: Did not find index %s in the list of portals. Try 'mapper portals' to see the list.\n", pnum))
   end
end

function map_bouncerecall (name, line, wildcards)
   wildcards[1] = Trim(wildcards[1])
   if wildcards[1]=="" then
      if bounce_recall and bounce_recall.dir then
         Note("\nBOUNCERECALL: Currently set to '"..bounce_recall.dir.."'")
      else
         Note("\nBOUNCERECALL: Not currently set.")
      end
      return
   elseif wildcards[1]=="clear" then
      bounce_recall = nil
      Note("\nBOUNCERECALL: cleared.")
      dbCheckExecute(string.format("DELETE from storage where name is %s;", fixsql("bounce_recall")))
      return
   end


   local pnum = tonumber(wildcards[1])

   if pnum==nil then
      Note("\nBOUNCERECALL FAILED: The required parameter for mapper bouncerecall is <recall_portal_index>. Current portal indexes can be found in the 'mapper portals' output.\n")
      return
   end

   local q = "select area, name, touid, fromuid, dir, exits.date_added, exits.level from exits,rooms where exits.touid=rooms.uid and exits.fromuid in ('*','**') order by area,touid"
   local count = 1
   local found = false
   for row in db:nrows(q) do
      if count == pnum then
         if row.fromuid == "**" then
            bounce_recall = {dir=row.dir, uid=row.touid}
            Note("\nBOUNCERECALL: Set recall portal #"..pnum.." ("..row.dir..") as the bounce recall for recall-friendly noportal rooms.")
            dbCheckExecute(string.format("INSERT OR REPLACE INTO storage (name, data) VALUES (%s,%s);", fixsql("bounce_recall"), fixsql(serialize.save("bounce_recall"))))
         else
            Note("\nBOUNCERECALL FAILED: Portal #"..pnum.." is not a recall portal. You must choose a mapper portal that uses either the recall or home commands for the bounce recall.")
         end
         found = true
      end
      count = count + 1
   end
   if found == false then
      world.Note(string.format("\nBOUNCERECALL FAILED: Did not find index %s in the list of portals. Try 'mapper portals' to see the list.\n", pnum))
   end
end

function map_areas (name, line, wildcards)
   local line = ""
   local query = ""
   local area = wildcards[1] or ""
   local count = 0

   local hr = "| keyword    | Area Name                               | Explored |"
   local hl = "+------------+-----------------------------------------+----------+"
   local fmt = "| %10.10s | %-39.39s | %8.8s |"
   if area == "" then
      query = "SELECT uid, name FROM areas WHERE uid in (SELECT DISTINCT area FROM rooms) ORDER BY name;"
      intro = "The following areas have been mapped:"
   else
      query = string.format("SELECT uid, name FROM areas WHERE name LIKE %s AND uid in (SELECT DISTINCT area FROM rooms) ORDER BY name;", fixsql("%"..area.."%"))
      intro = string.format("The following areas matching '%s' have been mapped:",area)
   end -- if area

   Note ("\n"..intro)
   Note (hl)
   Note (hr)
   Note (hl)

   for row in db:nrows(query) do
      query2 = string.format("SELECT count(uid) as count FROM rooms WHERE area=%s;",fixsql(row.uid))
      for row2 in db:nrows(query2) do
         line = string.format(fmt,row.uid, row.name, row2.count)
      end
      Note (line)
      count = count + 1
      BroadcastPlugin(999, "repaint")
   end

   Note (hl)
   line = string.format ("Found %s areas.\n", count)
   Note (line)
end

-- map_list function contributed by Spartacus
function map_list (name, line, wildcards)
   -- ok, so if I want to lookup a room in my db, I don't want it only if the mapper can find a sw in a certain # of rooms.
   -- if it is in the db, I want its vnum and area, so that I can figure out how to get there if the mapper does not know.
   local area = ""
   local count = 0
   Note("+------------------------------ START OF SEARCH -------------------------------+")
   -- find matching rooms using FTS3
   local name = "%"..wildcards[1].."%"
   if string.sub(wildcards[1],1,1) == "\"" and string.sub(wildcards[1],-1) == "\"" then
      name = string.sub(wildcards[1],2,-2)
   end
   for row in db:nrows(string.format ("SELECT uid, name FROM rooms_lookup WHERE name LIKE %s", fixsql (name))) do
      if count < 100 then
         for a in db:nrows(string.format ("SELECT area FROM rooms WHERE uid = %s", row.uid)) do
            area = a.area
         end -- for
         print (string.format("(%s) %s is in area \"%s\"",row.uid, row.name, area))
      end
      count = count + 1
   end   -- finding room
   if count >= 100 then
      mapper.mapprint(string.format("More than 100 search results found. Aborting query. Try a more specific search phrase than '%s'.",wildcards[1]))
   end
   Note("+-------------------------------- END OF SEARCH -------------------------------+")
end -- map_list

function map_cexits_delete (name, line, wildcards)
   local query = string.format("delete from exits where fromuid=%s and dir not in ('n','s','e','w','d','u');", fixsql(current_room))
   dbCheckExecute(query)
   for k,v in pairs(rooms[current_room].exits) do
      if #k > 1 then
         rooms[current_room].exits[k] = nil
         rooms[current_room].exit_locks[k] = nil
      end
   end
   mapper.draw (current_room)
   print("Removed custom exits from the current room.")
end

function map_cexits_purge (name, line, wildcards)
   local query = "delete from exits where dir not in ('n','s','e','w','d','u');"
   dbCheckExecute(query)
   for k,v in pairs(rooms) do
      for l,w in pairs(v.exits) do
         if #l > 1 then
            rooms[k].exits[l] = nil
            rooms[k].exit_locks[l] = nil
         end
      end
   end
   mapper.draw (current_room)
   print("Purged all custom exits.")
end

function custom_exit_list (name, line, wildcards)
   local line = ""
   local count = 0
   local query
   local display_limit = 30

   res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
   luastmt = "gmcpdata = " .. gmcparg
   assert(loadstring (luastmt or "")) ()
   local current_area = gmcpval("zone")

   area = Trim(wildcards [1] or "")
   query = string.format("select uid, name, area, dir, touid from rooms inner join exits on rooms.uid = fromuid where lower(area) like %s and dir not in ('n','s','e','w','d','u') and fromuid not in ('*','**') order by area, uid", fixsql("%" .. area .. "%"))

   if area == "" then
      intro = "The following rooms have custom exits:"
   else
      if area == "here" then
         area = current_area
         query = string.format("select uid, name, area, dir, touid from rooms inner join exits on rooms.uid = fromuid where lower(area) is %s and dir not in ('n','s','e','w','d','u') and fromuid not in ('*','**') order by area, uid", fixsql(area))
         intro = "The following rooms in the current area have custom exits:"
      else
         intro = string.format("The following rooms in areas partially matching '%s' have custom exits:",area)
      end
   end

   hr = "| area       | room name            | rm uid  | dir            | to uid  |"
   hl = "+------------+----------------------+---------+----------------+---------+"

   -- area - room name - room uid - direction - destination uid
   fmt = "| %10.10s | %-20.20s | %7.7s | %-14.14s | %7.7s |"
   -- print ("Query: " .. query)
   world.Note ("\n"..intro)
   world.Note (hl)
   world.Note (hr)
   world.Note (hl)
   for row in db:nrows(query) do
      line = string.format(fmt,row.area, row.name, row.uid, row.dir, row.touid)
      Hyperlink(string.format("mapper goto %s",row.uid), line, string.format("%s",row.dir), "", "", false)
      print("")
      count = count + 1
      BroadcastPlugin(999, "repaint")
   end -- custom exits query
   world.Note (hl)
   line = string.format ("Found %s custom exits.", count)
   print (line.."\n")
end -- custom_exits_list


function show_this_room (name, line, wildcards)
   local room = rooms[current_room]
   if room ~= nil then
      Note("Details about this room:")
      Note("+---------------------------+")
      Note("Name: "..(room.name or ""))
      Note("ID: "..(current_room or ""))
      Note("Area: "..(room.area or ""))
      Note("Terrain: "..(room.terrain or ""))
      Note("Info: "..(room.info or ""))
      Note("Notes: "..(room.notes or ""))
      local flags = ''
      if room.noportal == 1 then
         flags = flags .. ' noportal'
      end
      if room.norecall == 1 then
         flags = flags .. ' norecall'
      end
      Note("Flags:", flags)
      Note("Exits: ")
      tprint(room.exits)
      Tell("Exit locks: ")
      if room.exit_locks then
         Note("")
         tprint(room.exit_locks)
      else
         Note("none")
      end
      Note("+---------------------------+\n")
   else
      Note("THISROOM ERROR: You need to type 'LOOK' first to initialize the mapper before trying to get room information.")
   end
end -- show_this_room


-- show_known_unmapped_exits function contributed by Spartacus
function show_known_unmapped_exits (name, line, wildcards)
   -- I want to get a list of exits whose destinations are not yet in the rooms table (i.e. I have not gone through the exit?)
   -- select uid, name, area from rooms inner join exits on rooms.uid = fromuid where area = area and touid not in (select uid from rooms)
   local line = ""
   local count = 0
   local query
   local display_limit = 30

   res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
   luastmt = "gmcpdata = " .. gmcparg
   if (gmcparg ~= "") then -- in case the user has an old gmcp handler that clears room on room.wrongdir
      assert(loadstring (luastmt or "")) ()
   end
   local current_area = gmcpval("zone")

   area = Trim(wildcards [1] or "")

   if area == "" then
      query = "select area, count(dir) as cnt from rooms inner join exits on rooms.uid = fromuid where touid not in (select uid from rooms) group by area"
      hr = "| area       | count |"
      hl = "+------------+-------+"
      intro = "The following areas have unmapped exits:"
      fmt = "| %10.10s | %5d |"
   else
      if area == "here" then
         area = current_area
         intro = "The following rooms in the current area have unmapped exits:"
      else
         intro = string.format("The following rooms in areas matching '%s' have unmapped exits:",area)
         area = "%"..area.."%"
      end
      query = string.format("select uid, name, area, dir, touid from rooms inner join exits on rooms.uid = fromuid where lower(area) like %s and touid not in (select uid from rooms) order by area, uid", fixsql(area))
      hr = "| area       | room name            | rm uid  | dir | to uid  |"
      hl = "+------------+----------------------+---------+-----+---------+"
      -- area - room name - room uid - direction - destination uid
      fmt = "| %10.10s | %-20.20s | %7.7s | %-3.3s | %7.7s |"
   end -- if area

   -- print ("Query: " .. query)
   world.Note ("\n"..intro)
   world.Note (hl)
   world.Note (hr)
   world.Note (hl)
   for row in db:nrows(query) do
      if area == "" then
         line = string.format(fmt,row.area, row.cnt)
         world.Note (line)
         count = count + row.cnt
      else
         line = string.format(fmt,row.area, row.name, row.uid, row.dir, row.touid)
         Hyperlink(string.format("mapper goto %s",row.uid), line, "Click to attempt to walk here", "", "", false)
         print("")
         count = count + 1
      end -- if count
   end -- unmapped rooms query
   world.Note (hl)
   line = string.format ("Found %s unmapped exits.", count)
   print (line.."\n")
end -- show_known_unmapped_exits

function map_portal_delete (name, line, wildcards)
   local keywords = wildcards[1]
   local target_index = nil
   if string.sub(keywords,1,1) == "#" and type(tonumber(string.sub(keywords,2)))=="number" then
      target_index = tonumber(string.sub(keywords,2))
      local q = "select area, touid, dir from exits,rooms where exits.touid=rooms.uid and exits.fromuid in ('*','**') order by area,touid"
      local count = 0
      local found = false
      for row in db:nrows(q) do
         count = count + 1
         if count == target_index then
            keywords = row.dir
            found = true
         end
      end
      if found == false then
         world.Note(string.format("\nDELETE FAILED: Did not find portal #%s in the list of portals. Try 'mapper portals' to see the list.\n", target_index))
         return
      end
   end

   local portal_exists = false
   for n in db:nrows (string.format ("SELECT * FROM exits WHERE fromuid in ('*','**') AND dir = %s", fixsql(keywords))) do
      portal_exists = true
   end

   if portal_exists then
      print (string.format("Deleted mapper portal"..(((target_index ~= nil) and " index #"..target_index) or "").." with keywords '%s'.", keywords))
   else
      print (string.format("DELETE FAILED: Did not find a mapper portal with keywords '%s'.", keywords))
   end

   query = string.format("DELETE FROM exits WHERE fromuid in ('*','**') AND dir = %s;", fixsql(keywords))
   dbCheckExecute(query)
end -- map_portal_delete

function map_portal_purge(name, line, wildcards)
   query = "DELETE FROM exits WHERE fromuid in ('*','**');"
   dbCheckExecute(query)
   print ("Purged all mapper hand-held exits.")
end

function positive_integer_check(input)
   input = tonumber(input)
   if input == nil or input < 0 or input % 1 ~= 0 then
      return false
   else
      return true
   end
end

function level_check(input)
   input = tonumber(input)
   if positive_integer_check(input) == false or input > 291 then
      return false
   else
      return true
   end
end

function map_portal_recall (name, line, wildcards)
   -- flag a portal as using "recall"
   local query = "INSERT OR REPLACE INTO rooms (uid, name, area, date_added) VALUES ('**', '___HERE___', '___EVERYWHERE___', DATETIME('NOW'))"
   dbCheckExecute(query)

   local pnum = tonumber(wildcards[1])

   if pnum==nil then
      world.Note("\nPORTALRECALL FAILED: The required parameter for mapper portalrecall is <portal_index>. Current portal indexes can be found in the 'mapper portals' output.\n")
      return
   end

   local q = "select area, name, touid, fromuid, dir, exits.date_added, exits.level from exits,rooms where exits.touid=rooms.uid and exits.fromuid in ('*','**') order by area,touid"
   local count = 1
   local found = false
   for row in db:nrows(q) do
      if count == pnum then
         query = string.format ([[
            INSERT OR REPLACE INTO exits (dir, fromuid, touid, level, date_added)
            VALUES (%s, %s, %s, %s, %s);
            ]],
            fixsql(row.dir),  -- direction (eg. "n")
            fixsql(((row.fromuid == "*") and "**") or "*"),  -- toggle between '*' and '**'
            fixsql(row.touid),    -- destination room
            fixsql(row.level),
            fixsql(row.date_added)
         )
         dbCheckExecute(query)
         query = string.format ([[
            DELETE FROM exits WHERE dir=%s AND fromuid=%s AND touid=%s AND level=%s;
            ]],
            fixsql(row.dir),  -- direction (eg. "n")
            fixsql(row.fromuid),  -- remove the old pre-toggle entry
            fixsql(row.touid),    -- destination room
            fixsql(row.level)
         )
         dbCheckExecute(query)

         world.Note(string.format("\nPORTALRECALL: Recall flag %s portal '%s' to '%s'.\n",((row.fromuid == "*") and "added to") or "removed from",row.dir,row.name))
         found = true
      end
      count = count + 1
   end
   if found == false then
      world.Note(string.format("\nPORTALRECALL FAILED: Did not find index %s in the list of portals. Try 'mapper portals' to see the list.\n", pnum))
   end
end -- map_recall

-- map_portal function contributed by Spartacus
function map_portal (name, line, wildcards)
   -- store portal as an exit from anywhere to the current room
   res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
   luastmt = "gmcpdata = " .. gmcparg
   assert (loadstring (luastmt or "")) ()

   if not current_room then
      print ("PORTAL FAILED: No room received from the mud yet. Try using the 'LOOK' command first.")
      return
   end -- no room number.map_portal

   if current_room == "-1" then
      print("PORTAL FAILED: Cannot link portals to unmappable rooms.")
      return
   end

   local level = tonumber(utils.inputbox ("Please enter the level of this portal, or leave at 0 for the default", "Portal Level", "0", "Courier", 9, {validate=level_check}))

   if not level then
     Note("Portal creation cancelled.")
     return
   end

   local hhp_room_exists = 0
   local query = ""
   -- first check to see if our special room exists...
   for row in db:nrows("select * from rooms where uid='*'") do
      hhp_room_exists = hhp_room_exists + 1
   end
   if hhp_room_exists == 0 then
      query = "INSERT OR REPLACE INTO rooms (uid, name, area, date_added) VALUES ('*', '___HERE___', '___EVERYWHERE___', DATETIME('NOW'))"
      dbCheckExecute(query)
   end
   print (string.format("Storing %s as a portal to %s.", wildcards [1], current_room))
   print (string.format("\nPortal '%s' to '%s' given minimum level lock of %s.\n",wildcards [1], current_room,level))
   query = string.format ("INSERT OR REPLACE INTO exits (dir, fromuid, touid, date_added, level) VALUES (%s, %s, %s, DATETIME('NOW'), %s);",
      fixsql  (wildcards [1]),  -- direction (eg. "n")
      fixsql  ("*"),         -- from current room
      fixsql  (current_room),    -- destination room
      fixsql(level) -- minimum level of the portal
   )
   dbCheckExecute(query)

end -- map_portal

function string:split(sep)
   local sep, fields = sep or ":", {}
   local pattern = string.format("([^%s]+)", sep)
   self:gsub(pattern, function(c) fields[#fields+1] = c end)
   return fields
end

function map_portal_level (name, line, wildcards)

   local keys = wildcards[1]:split(" ")
   local pnum = tonumber(keys[1])
   local level = tonumber(keys[2])

   if pnum==nil or level==nil then
      world.Note("\nPORTALLEVEL FAILED: The parameters for mapper portal level are <portal_index> <min_level>. Current portal indexes can be found in the 'mapper portals' output.\n")
      return
   end

   if level < 0 then
      level = 0
   end

   local q = "select area, name, touid, fromuid, dir, exits.date_added from exits,rooms where exits.touid=rooms.uid and exits.fromuid in ('*','**') order by area,touid"
   local count = 1
   local found = false
   for row in db:nrows(q) do
      if count == pnum then
         query = string.format ([[
            INSERT OR REPLACE INTO exits (dir, fromuid, touid, level, date_added)
            VALUES (%s, %s, %s, %s, %s);
            ]],
            fixsql(row.dir),  -- direction (eg. "n")
            fixsql(row.fromuid),  -- from '*' or '**'
            fixsql(row.touid),    -- destination room
            fixsql(level),
            fixsql(row.date_added)
         )
         dbCheckExecute(query)
         world.Note(string.format("\nPortal '%s' to '%s' given minimum level lock of %s.\n",row.dir,row.name,level))
         found = true
      end
      count = count + 1
   end
   if found == false then
      world.Note(string.format("\nPORTALLEVEL FAILED: Did not find index %s in the list of portals. Try 'mapper portals' to see the list.\n", pnum))
   end
end -- map_portal_level

-- map_portal_list function contributed by Spartacus
function map_portal_list ()
   local line
   local cmd
   local txt
   -- show portals stored in the exits table
   local hl = "+-----+------------+----------------------+-------+----------------------+-----+"
   local hr = "|   # | area       | room name            |  vnum | portal keywords      | lvl |"

   world.Note ("\n"..hl)
   world.Note (hr)
   world.Note (hl)

   local q = "select area, name, fromuid, touid, dir,level from exits, rooms where exits.touid=rooms.uid and exits.fromuid in ('*','**') order by area,touid"
   local count = 0
   for row in db:nrows(q) do
      count = count + 1
      line = string.format("| %+3.3s | %-10.10s | %-20.20s | %+5.5s | %-20.20s | %+3.3s |", count, row.area, row.name, row.touid, row.dir, row.level)
      if row.level <= mylevel+(mytier*10) then
         -- make the whole line click-able
         cmd = "mapper goto " .. row.touid
         txt = "click here to run to " .. row.name
         Hyperlink(cmd, line, txt, (((row.fromuid=="*") and "") or "red"), "", false)
         Note ()
      else
         world.Note(line)
      end -- if row.level
   end -- for row (portals query)
   world.Note (hl.."\n")

end -- map_portal_list

BASE_CEXIT_DELAY = 2

function change_cexit_delay(name, line, wildcards)
   temp_cexit_delay = tonumber(wildcards[1])
   Note("")
   if temp_cexit_delay == nil or temp_cexit_delay < BASE_CEXIT_DELAY or temp_cexit_delay > 30 then
      Note("CEXIT_DELAY FAILED: Invalid delay given ("..wildcards[1].."). Must be a number from 2 to 30.")
      temp_cexit_delay = nil
   end
   Note("CEXIT_DELAY: The next mapper custom exit will have ".. (temp_cexit_delay or BASE_CEXIT_DELAY) .." seconds to complete.\n")
end

function ExecuteWithWaits(cexit_command)
   wait.make (function()
      local partial_cexit_command = cexit_command
      local strbegin,strend = string.find(partial_cexit_command,";?wait%(%d*.?%d+%);?")
      while strbegin do
         strbegin,strend = string.find(partial_cexit_command,";?wait%(%d*.?%d+%);?")
         if strbegin ~= nil and strbegin ~= 1 then
            Execute(string.sub(partial_cexit_command,1,strbegin-1))
         end
         if strend then
            local wait_time = tonumber(string.match(string.sub(partial_cexit_command,strbegin,strend),"wait%((%d*.?%d+)%)"))
            SendNoEcho("echo {mapper_wait}wait("..wait_time..")")
            line, wildcards = wait.regexp("^\\{mapper_wait\\}wait\\(([0-9]*\\.?[0-9]+)\\)",nil,trigger_flag.OmitFromOutput)
            Note("CEXIT WAIT: waiting for "..wait_time.." seconds before continuing.")
            BroadcastPlugin(999, "repaint")
            wait.time(wait_time)
            partial_cexit_command = string.sub(partial_cexit_command, strend+1)
         end
      end
      Execute(partial_cexit_command)
   end)
end

-- custom_exit function contributed by Spartacus
function custom_exit (name, line, wildcards)

   local remap = {
      n = "north",
      w = "west",
      s = "south",
      e = "east",
      u = "up",
      d = "down"
   }
   local cexit_command = wildcards [1] or ""
   local cexit_start

   if cexit_command == "" then
      world.Note("Nothing to do!")
      return
   end -- if cexit_command

   -- the current system makes standard letter exit (n,e,s,w,d,u) cexits not usable, so remap them
   -- to their long word forms
   if remap[cexit_command] then
      cexit_command = remap[cexit_command]
   end

   if current_room then
      cexit_start = current_room
   else
      world.Note("CEXIT FAILED: No room received from the mud yet. Try using the 'LOOK' command first.")
      return
   end -- if current_room

   if cexit_start == "-1" then
      world.Note ("CEXIT FAILED: You cannot link custom exits from unmappable rooms.")
      return
   end

   wait.make (function()
      local cexit_delay = temp_cexit_delay or BASE_CEXIT_DELAY
      local added_waits = 0
      for wait_secs in string.gmatch(cexit_command, "wait%((%d*.?%d+)%)") do
         added_waits = added_waits + tonumber(wait_secs)
      end
      world.Note("CEXIT: WAIT FOR CONFIRMATION BEFORE MOVING.\nThis should take about "..cexit_delay+added_waits.." seconds"..(((added_waits ~= 0) and " (includes "..added_waits.." seconds in added waits)") or "")..".")
      BroadcastPlugin(999, "repaint")
      ExecuteWithWaits(cexit_command)

      wait.time(cexit_delay+added_waits)
      temp_cexit_delay = nil
      cexit_dest = current_room
      if cexit_dest then
         if cexit_dest == "-1" then
            world.Note ("CEXIT FAILED: You cannot link custom exits to unmappable rooms.")
         elseif cexit_dest ~= cexit_start then
            world.Note (string.format("Custom Exit CONFIRMED: %s (%s) -> %s", cexit_start, cexit_command, cexit_dest))
            dbCheckExecute(string.format ([[
               INSERT OR REPLACE INTO exits (dir, fromuid, touid, date_added)
               VALUES (%s, %s, %s, DATETIME('NOW'));
               ]], fixsql  (string.lower(cexit_command)),  -- direction (eg. "n")
               fixsql  (cexit_start),  -- from current room
               fixsql  (cexit_dest) -- destination room
            ))
            rooms[cexit_start].exits[cexit_command] = cexit_dest
            rooms[cexit_start].exit_locks[cexit_command] = "0"
            mapper.draw (current_room)
         else
            world.Note (string.format("CEXIT FAILED: Custom Exit %s leads back here!", cexit_command))
         end
      else
         world.Note ("CEXIT FAILED: Need to know where we ended up.")
      end
   end)
end -- custom_exit

function save_room_to_database (uid,room)

   assert (uid, "No UID supplied to save_room_to_database")
   local area_exists = false
   for n in db:nrows (string.format ("SELECT uid FROM areas where uid=%s", fixsql(room.area))) do
      area_exists = true
   end
   if not area_exists then
      Send_GMCP_Packet("request area")
      return false
   end

   dbCheckExecute(string.format (
         "INSERT OR REPLACE INTO rooms (uid, name, terrain, info, x, y, z, area, noportal, norecall, date_added) VALUES (%s, %s, %s, %s, %i, %i, %i, %s, %d, %d, DATETIME('NOW'));",
            fixsql (uid),
            fixsql (room.name),
            fixsql (room.terrain),
            fixsql (room.info),
            room.x or 0, room.y or 0, room.z or 0, fixsql(room.area),
            room.noportal or 0,
            room.norecall or 0
         ))

   local exists = false
   for n in db:nrows(string.format ("SELECT * FROM rooms_lookup WHERE uid = %s", fixsql(uid))) do
      exists = true
   end
   -- don't add multiple times, maintaining backwards database compatibility (there's no uniqueness constraint on rooms_lookup.uid)
   if not exists then
      dbCheckExecute(string.format ("INSERT INTO rooms_lookup (uid, name) VALUES (%s, %s);", fixsql(uid), fixsql(room.name)))
   else
      dbCheckExecute(string.format ("DELETE FROM rooms_lookup WHERE uid = %s",fixsql(uid)))
      dbCheckExecute(string.format ("INSERT INTO rooms_lookup (uid, name) VALUES (%s, %s);", fixsql(uid), fixsql(room.name)))
   end

   room_not_in_database [uid] = nil

   if show_database_mods then
      mapper.mapprint ("Added room", uid, "to database. Name:", room.name)
   end -- if
   return true
end -- function save_room_to_database

function fix_up_exit ()
   local room = rooms [from_room]

   dbCheckExecute(string.format ("UPDATE exits SET touid = %s WHERE fromuid = %s AND dir = %s;",
        fixsql  (current_room),     -- destination room
        fixsql  (from_room),       -- from previous room
        fixsql  (last_direction_moved)  -- direction (eg. "n")
   ))

--   if show_database_mods then
      mapper.mapprint ("Fixed exit", last_direction_moved, "from room", from_room, "to be to", current_room)
--   end -- if

   room.exits [last_direction_moved] = current_room

   last_direction_moved = nil
   from_room = nil
end -- fix_up_exit

function map_purgezone (name, line, wildcards)
   local zoneuid = string.gsub(wildcards[1], "^%s*(.-)%s*$", "%1")
   local found = false
   local zone_name = ""
   if #(wildcards[1]) > 1 and string.sub(wildcards[1], 1, 1) == " " then

      for row in db:nrows(string.format("SELECT uid,name FROM areas WHERE uid = %s;", fixsql (zoneuid))) do
         zone_name = row.name
         found = true
      end   -- finding area uid
   end

   if found == false then
      mapper.mapprint("Syntax: mapper purgezone <keyword>\nTry 'mapper areas' for a list of area keywords.\n")
      return
   end

   dbCheckExecute(string.format ("delete from exits where touid in (select uid from rooms where area = %s);",fixsql(zoneuid)))
   dbCheckExecute(string.format ("delete from exits where fromuid in (select uid from rooms where area = %s);",fixsql(zoneuid)))
   dbCheckExecute(string.format ("delete from rooms_lookup where uid in (select uid from rooms where area = %s);", fixsql(zoneuid)))
   dbCheckExecute(string.format ("delete from bookmarks where uid in (select uid from rooms where area = %s);", fixsql(zoneuid)))
   dbCheckExecute(string.format ("delete from rooms where area = %s;", fixsql(zoneuid)))
   dbCheckExecute(string.format ("delete from areas where uid = %s;", fixsql(zoneuid)))

   rooms = {}
   areas[zoneuid] = nil
   mapper.mapprint ("Purged " .. zone_name .. " from the mapper database.")
   Send_GMCP_Packet("request room")
end

function room_purgeroom (room, uid)
   map_purgeroom(uid)
   mapper.draw(current_room)
end

function map_purgeroom (uid, new_area)
   if new_area then
      dbCheckExecute(string.format ("delete from exits where touid = %s and fromuid not in (select uid from rooms where area = %s);",fixsql(uid),fixsql(new_area)))
   else
      dbCheckExecute(string.format ("delete from exits where touid = %s;",fixsql(uid)))
   end
   dbCheckExecute(string.format ("delete from exits where fromuid = %s;",fixsql(uid)))
   dbCheckExecute(string.format ("delete from rooms_lookup where uid = %s;", fixsql(uid)))
   dbCheckExecute(string.format ("delete from bookmarks where uid = %s;", fixsql(uid)))
   dbCheckExecute(string.format ("delete from rooms where uid = %s;", fixsql(uid)))
   rooms[uid] = nil
   for k,v in pairs(rooms) do
      for j,u in pairs(v.exits) do
         if u == uid then
            v.exits[j] = nil
         end
      end
   end
end

function map_clearcache()
   rooms = {}
   mapper.mapprint ("Cleared local room cache.")
end

function load_room_from_database (uid)
   local room
   local u = tostring(uid)
   assert (uid, "No UID supplied to load_room_from_database")

   -- if not in database, don't look again
   if room_not_in_database [u] then
      return nil
   end -- no point looking

   for row in db:nrows(string.format ("SELECT * FROM rooms WHERE uid = %s", fixsql (u))) do
      room = {
      name = row.name,
      area = row.area,
      building = row.building,
      terrain = row.terrain,
      info = row.info,
      notes = row.notes,
      x = row.x or 0,
      y = row.y or 0,
      z = row.z or 0,
      noportal = row.noportal,
      norecall = row.norecall,
      exits = {},
      exit_locks = {}
      }

      for exitrow in db:nrows(string.format ("SELECT * FROM exits WHERE fromuid = %s", fixsql (u))) do
         room.exits [exitrow.dir] = tostring (exitrow.touid)
         room.exit_locks [exitrow.dir] = tostring(exitrow.level)
      end -- for each exit

   end   -- finding room

   if room then
      if not rooms then
         -- this shouldn't even be possible. what the hell.
         rooms = {}
      end
      rooms [u] = room
      for row in db:nrows(string.format ("SELECT * FROM bookmarks WHERE uid = %s", fixsql (u))) do
         rooms [u].notes = row.notes
      end   -- finding room

      return room
   end -- if found

   -- room not found in database
   room_not_in_database [u] = true
   return nil

end -- load_room_from_database

function create_tables ()
   -- create rooms table
   dbCheckExecute([[
   PRAGMA foreign_keys = ON;
   PRAGMA journal_mode=WAL;

   CREATE TABLE IF NOT EXISTS areas (
      areaid      INTEGER PRIMARY KEY AUTOINCREMENT,
      uid         TEXT    NOT NULL,   -- vnum or how the MUD identifies the area
      name        TEXT,               -- name of area
      date_added  DATE,               -- date added to database
      texture     TEXT,               -- background area texture
      color       TEXT,               -- ANSI colour code.
      UNIQUE (uid)
   );
   CREATE INDEX IF NOT EXISTS areas_uid_index ON areas (uid);
   CREATE INDEX IF NOT EXISTS areas_name_index ON areas (name);

   CREATE TABLE IF NOT EXISTS environments (
      environmentid INTEGER PRIMARY KEY AUTOINCREMENT,
      uid           TEXT    NOT NULL,   -- code for the environment
      name          TEXT,               -- name of environment
      color         INTEGER,            -- ANSI colour code
      date_added    DATE,               -- date added to database
      UNIQUE (uid)
   );
   CREATE INDEX IF NOT EXISTS name_index ON environments (name);

   CREATE TABLE IF NOT EXISTS rooms (
      roomid        INTEGER PRIMARY KEY AUTOINCREMENT,
      uid           TEXT NOT NULL,   -- vnum or how the MUD identifies the room
      name          TEXT,            -- name of room
      area          TEXT,            -- which area
      building      TEXT,            -- which building it is in
      terrain       TEXT,            -- eg. road OR water
      info          TEXT,            -- eg. shop,healer
      notes         TEXT,            -- player notes
      x             INTEGER,
      y             INTEGER,
      z             INTEGER,
      date_added    DATE,            -- date added to database
      UNIQUE (uid),
      FOREIGN KEY(area) REFERENCES areas(uid)
   );
   CREATE INDEX IF NOT EXISTS info_index ON rooms (info);
   CREATE INDEX IF NOT EXISTS terrain_index ON rooms (terrain);
   CREATE INDEX IF NOT EXISTS area_index ON rooms (area);
   CREATE INDEX IF NOT EXISTS rname_index ON rooms (name);

   CREATE TABLE IF NOT EXISTS exits (
      dir         TEXT    NOT NULL, -- direction, eg. "n", "s"
      fromuid     TEXT    NOT NULL, -- exit from which room (in rooms table)
      touid       TEXT    NOT NULL, -- exit to which room (in rooms table)
      level       STRING  NOT NULL DEFAULT '0', -- minimum level to make use of this exit
      date_added  DATE,             -- date added to database
      PRIMARY KEY(fromuid, dir),
      FOREIGN KEY(fromuid) REFERENCES rooms(uid)
   );
   CREATE INDEX IF NOT EXISTS fromuid_index ON exits (fromuid);
   CREATE INDEX IF NOT EXISTS touid_index   ON exits (touid);
   ]])

   -- Since the MUD sends terrain as a string and not as an integer,
   -- it was wrong to originally produce rooms with integer terrains.
   -- Or maybe it's wrong for the MUD to send strings. Either way, we now
   -- have databases with inconsistent data. So let's make it consistent.
   dbCheckExecute("UPDATE OR IGNORE rooms SET terrain = ifnull((SELECT name FROM environments WHERE environments.uid = rooms.terrain), rooms.terrain);")

   -- check if rooms_lookup table exists
   dbCheckExecute([[
   BEGIN TRANSACTION;
   DROP TABLE IF EXISTS rooms_lookup;
   CREATE VIRTUAL TABLE rooms_lookup USING FTS3(uid, name);
   INSERT INTO rooms_lookup (uid, name) SELECT uid, name FROM rooms;
   COMMIT;
   ]])
end -- function create_tables

function check_rooms_flags()
   local flag_exists = { noportal = false,
                         norecall = false }
   for a in db:nrows "PRAGMA table_info('rooms')" do
      if flag_exists[a.name] ~= nil then
         flag_exists[a.name] = true
      end
   end

   for k, v in pairs(flag_exists) do
      if not v then
         local sql = 'ALTER TABLE rooms ADD ' .. k .. ' INTEGER'
         dbCheckExecute(sql)
      end
   end
end -- function check_rooms_flags

function get_room (uid)

   -- look it up
   local ourroom = rooms [uid]

   -- not cached - see if in database
   if not ourroom then
      ourroom = load_room_from_database (uid)
      rooms [uid] = ourroom -- cache for later
   end -- not in cache

   if not ourroom then
      return nil
   end -- if

   local room = copytable.deep (ourroom)
   room.bordercolour = configs.ROOM_COLOUR.colour
   if areas[room.area] then
      room.texture = areas[room.area].texture
      if areas[room.area].color ~= "" then
         room.bordercolour = areas[room.area].color or configs.ROOM_COLOUR.colour
      end
      room.area = areas[room.area].name or string.format ("%s", room.area or "<unknown>")
   end

   if uid == current_room then
      current_area = room.area
   end -- if

   -- build hover message
   local environmentname = room.terrain
   if tonumber (environmentname) then
      environmentname = environments [tonumber (environmentname)]
   end -- convert to name

   local terrain = ""
   if environmentname and environmentname ~= "" then
      terrain = "\nTerrain: " .. capitalize (environmentname)
   end -- if terrain known

   local info = ""
   if room.info and room.info ~= "" then
      info = "\nInfo: " .. capitalize (room.info)
   end -- if info known

   local notes = ""
   if room.notes and room.notes ~= "" then
      notes = "\nNote: " .. room.notes
   end -- if notes

   local flags = ""
   if room.norecall == 1 then
         flags = flags.."norecall "
   end
   if room.noportal == 1 then
         flags = flags.."noportal"
   end
   if flags ~= "" then
      flags = "\nFlags: "..string.gsub(flags," ",", ")
   end

   local texits = {}
   for dir in pairs (room.exits) do
      table.insert (texits, dir)
   end -- for
   table.sort (texits)

   local areaname = room.area
   if tonumber (areaname) then
      areaname = areas [tonumber (areaname)].name
   end -- convert to name

   room.hovermessage = string.format (
      "%s\tExits: %s\nRoom: %s\nArea: %s%s%s%s%s",
      room.name,
      table.concat (texits, ", "),
      uid,
      areaname,
      terrain,
      info,
      notes,
      flags
      -- depth,
      -- table.concat (path, ",")
      )

   room.borderpen = 0 -- solid
   room.borderpenwidth = 1
   room.fillcolour = 0xff0000
   room.fillbrush = 1 -- no fill
   -- special room fill colours
   local special_room = false
   if room.info and room.info ~= "" then
      if string.match (room.info, "shop") then
         special_room = true
         room.fillcolour = configs.SHOP_FILL_COLOUR.colour
         room.fillbrush = 0  -- solid
      elseif string.match (room.info, "healer") then
         special_room = true
         room.fillcolour = configs.HEALER_FILL_COLOUR.colour
         room.fillbrush = 0  -- solid
      elseif string.match (room.info, "guild") then
         special_room = true
         room.fillcolour = configs.GUILD_FILL_COLOUR.colour
         room.fillbrush = 0 -- solid
      elseif string.match (room.info, "trainer") then
         special_room = true
         room.fillcolour = configs.TRAINER_FILL_COLOUR.colour
         room.fillbrush = 0 -- solid
      elseif string.match (room.info, "questor") then
         special_room = true
         room.fillcolour = configs.QUESTOR_FILL_COLOUR.colour
         room.fillbrush = 0 -- solid
      elseif string.match (room.info, "bank") then
         special_room = true
         room.fillcolour = configs.BANK_FILL_COLOUR.colour
         room.fillbrush = 0  -- solid
      elseif string.match (room.info, "safe") then
         special_room = true
         room.fillcolour = configs.SAFEROOM_FILL_COLOUR.colour
         room.fillbrush = 0  -- solid
      end -- if
   end
   -- use terrain colour
   if environmentname and environmentname ~= "" and not special_room then
      if user_terrain_colour [environmentname] then
         room.fillcolour = user_terrain_colour [environmentname]
         room.fillbrush = 8  -- fine pattern
      elseif terrain_colours [environmentname] then
         room.fillcolour = colour_lookup [terrain_colours [environmentname]]
         room.fillbrush = 8  -- fine pattern
      else
         Send_GMCP_Packet("request sectors")
      end
   end -- if environmentname

   if uid == current_room then
      room.bordercolour = configs.OUR_ROOM_COLOUR.colour
      room.borderpenwidth = 3
   elseif room.area ~= current_area then
      room.bordercolour = configs.DIFFERENT_AREA_COLOUR.colour
   elseif room.info and string.match(room.info, "pk") then
      room.bordercolour = configs.PK_BORDER_COLOUR.colour
      room.borderpenwidth = 3
   end -- not in this area

   return room

end -- get_room

function room_edit_note (room, uid, newnotes)

   if uid == nil and current_room ~= nil then
      uid = current_room
      room = rooms[current_room]
   end

   if uid == nil then -- still nothing?
      print("No room received from the mud yet. Try using the 'LOOK' command first.")
      return
   end

   local notes, found

   for row in db:nrows(string.format ("SELECT * FROM bookmarks WHERE uid = %s", fixsql (uid))) do
      notes = row.notes
      found = true
   end   -- finding room

   if newnotes == nil or newnotes == "" then
      if found then
         newnotes = utils.inputbox ("Modify room comment (clear it to delete from database)", room.name, notes)
      else
         newnotes = utils.inputbox ("Enter room comment (creates a note for this room)", room.name, notes)
      end -- if
   end

   if not newnotes then
      return
   end -- if cancelled

   if newnotes == "" then
      if not found then
         mapper.mapprint ("No comment entered, note not saved.")
         return
      else
         dbCheckExecute(string.format (
         "DELETE FROM bookmarks WHERE uid = %s;",
         fixsql (uid)
         ))
         mapper.mapprint ("Note for room", uid, "deleted. Was previously:", notes)
         rooms [uid].notes = nil
         mapper.draw (current_room)
         return
      end -- if
   end -- if

   if notes == newnotes then
      return -- no change made
   end -- if

   if found then
      dbCheckExecute(string.format (
      "UPDATE bookmarks SET notes = %s, date_added = DATETIME('NOW') WHERE uid = %s;",
      fixsql (newnotes),
      fixsql (uid)
      ))
      mapper.mapprint ("Note for room", uid, "changed to:", newnotes)
   else
      dbCheckExecute(string.format (
      "INSERT INTO bookmarks (uid, notes, date_added) VALUES (%s, %s, DATETIME('NOW'));",
      fixsql (uid),
      fixsql (newnotes)
      ))
      mapper.mapprint ("Note added to room", uid, ":", newnotes)
   end -- if

   rooms [uid].notes = newnotes
   mapper.draw (current_room)

end -- room_edit_note

function room_edit_terrain_colour (room, uid)

   if not room.terrain then
      utils.msgbox ("This room does not have a terrain type", "Unknown terrain!", "ok", "!", 1)
      return
   end -- not known

   local environmentname = room.terrain
   if tonumber (environmentname) then
      environmentname = environments [tonumber (environmentname)]
   end -- convert to name

   local colour
   local colourtype = terrain_colours [environmentname]

   if colourtype then
      colour = colour_lookup [colourtype]
   end -- if type known

   if user_terrain_colour [environmentname] then
      colour = user_terrain_colour [environmentname]
   end -- if already have user colour

   local newcolour = PickColour (colour or 0x000000)
   if newcolour == -1 or newcolour == colour then
      return
   end -- cancelled

   if user_terrain_colour [environmentname] then
      dbCheckExecute(string.format (
      "UPDATE terrain SET color = %s, date_added = DATETIME('NOW') WHERE name = %s;",
      fixsql (newcolour),
      fixsql (environmentname)
      ))
      mapper.mapprint ("Colour for terrain '" .. environmentname .. "' changed to:", RGBColourToName (newcolour))
   else
      dbCheckExecute(string.format (
      "INSERT INTO terrain (name, color, date_added) VALUES (%s, %s, DATETIME('NOW'));",
      fixsql (environmentname),
      fixsql (newcolour)
      ))
      mapper.mapprint ("Colour for terrain '" .. environmentname .. "' is now", RGBColourToName (newcolour))
   end -- if

   user_terrain_colour [environmentname] = newcolour

   mapper.draw (current_room)

end -- room_edit_terrain_colour

function room_add_exit (room, uid)

   local available =  {
   n = "North",
   s = "South",
   e = "East",
   w = "West",
   u = "Up",
   d = "Down",
   }  -- end of available

   -- remove existing exits
   for k in pairs (room.exits) do
      available [k] = nil
   end -- for

   if next (available) == nil then
      utils.msgbox ("All exits already used.", "No free exits!", "ok", "!", 1)
      return
   end -- not known

   local chosen_exit = utils.listbox ("Choose exit to add", "Exits ...", available )
   if not chosen_exit then
      return
   end

   exit_destination = utils.inputbox ("Enter destination room identifier (number) for " .. available [chosen_exit], room.name, "")

   if not exit_destination then
      return
   end -- cancelled

   -- look it up
   local dest_room = rooms [exit_destination]

   -- not cached - see if in database
   if not dest_room then
      dest_room = load_room_from_database (exit_destination)
      rooms [exit_destination] = dest_room -- cache for later
   end -- not in cache

   if not dest_room then
      utils.msgbox ("Room " .. exit_destination .. " does not exist.", "Room does not exist!", "ok", "!", 1)
      return
   end -- if still not there

   dbCheckExecute(string.format ([[
      INSERT OR REPLACE INTO exits (dir, fromuid, touid, date_added)
      VALUES (%s, %s, %s, DATETIME('NOW'));
      ]],
      fixsql(chosen_exit),  -- direction (eg. "n")
      fixsql(uid),  -- from current room
      fixsql(exit_destination) -- destination room
      ))
   if show_database_mods then
      mapper.mapprint ("Added exit", available [chosen_exit], "from room", uid, "to room", exit_destination, "to database.")
   end -- if

   -- update in-memory table
   rooms [uid].exits [chosen_exit] = exit_destination

   mapper.draw (current_room)

end -- room_add_exit


function room_delete_exit (room, uid)

   local available =  {}  -- end of available

   -- construct available exits list for display
   for k,v in pairs (room.exits) do
      available [k] = k .. " --> " .. room.exits [k]
   end -- for

   if next (available) == nil then
      utils.msgbox ("There are no exits from this room.", "No exits!", "ok", "!", 1)
      return
   end -- not known

   local chosen_exit = utils.listbox ("Choose exit to delete", "Exits ...", available )
   if not chosen_exit then
      return
   end

   dbCheckExecute(string.format ([[
      DELETE FROM exits WHERE dir = %s AND fromuid = %s;
      ]],
      fixsql (chosen_exit),  -- direction (eg. "n")
      fixsql (uid)  -- from current room
   ))
   mapper.mapprint ("Deleted exit '"..chosen_exit.."' from room "..uid.." from database.")

   -- update in-memory table
   rooms[uid] = load_room_from_database(uid)

   mapper.draw (current_room)

end -- room_delete_exit


function room_change_exit (room, uid)

   local available =  {}  -- end of available

   -- construct available exits list for display
   for k,v in pairs (room.exits) do
      available [k] = k .. " --> " .. room.exits [k]
   end -- for

   if next (available) == nil then
      utils.msgbox ("There are no exits from this room.", "No exits!", "ok", "!", 1)
      return
   end -- not known

   local chosen_exit = utils.listbox ("Choose exit to change destination of:", "Exits ...", available )
   if not chosen_exit then
      return
   end

   exit_destination = utils.inputbox ("Enter destination room identifier (number) for " .. chosen_exit, room.name, room.exits[chosen_exit])

   if not exit_destination then
      return
   end -- cancelled

   -- look it up
   local dest_room = rooms [exit_destination]

   -- not cached - see if in database
   if not dest_room then
      dest_room = load_room_from_database (exit_destination)
      rooms [exit_destination] = dest_room -- cache for later
   end -- not in cache

   if not dest_room then
      utils.msgbox ("Room " .. exit_destination .. " does not exist.", "Room does not exist!", "ok", "!", 1)
      return
   end -- if still not there

   if exit_destination ~= room.exits[chosen_exit] then
      dbCheckExecute(string.format ([[
         UPDATE exits SET touid = %s WHERE dir = %s AND fromuid = %s;
         ]],
         fixsql (exit_destination),
         fixsql (chosen_exit),  -- direction (eg. "n")
         fixsql (uid)  -- from current room
      ))

      mapper.mapprint ("Modified exit", chosen_exit, "from room", uid, "to be to room", exit_destination, "in database.")

      -- update in-memory table
      rooms [uid].exits [chosen_exit] = exit_destination
      mapper.draw (current_room)
   else
      mapper.mapprint ("Destination unchanged for exit '"..chosen_exit.."'.")
   end

end -- room_change_exit

function room_lock_exit (room, uid)
   if uid == nil and current_room ~= nil then
      uid = current_room
      room = rooms[uid]
   end

   if uid == nil then -- still nothing? abort!
      print("No room received from the mud yet. Try using the 'LOOK' command first.")
      return
   end

   local available = {}

   -- construct available exits list for display
   for k,v in pairs (room.exits) do
      available [k] = k .. " --> " .. room.exits [k]
   end -- for

   if next (available) == nil then
      utils.msgbox ("There are no exits from this room.", "No exits!", "ok", "!", 1)
      return
   end -- not known

   local chosen_exit = utils.listbox ("Choose exit to lock:", "Exits ...", available )
   if not chosen_exit then
      return
   end -- cancelled

   exit_level = tostring(tonumber(utils.inputbox ("Enter level lock for " .. chosen_exit, room.name, room.exit_locks[chosen_exit],nil,nil,{validate=positive_integer_check}))) -- use tonumber to strip off any ".0"

   if exit_level == "nil" then
      return
   end -- cancelled

   if not rooms [uid].exit_locks then
      rooms [uid].exit_locks = {}
   end

   if exit_level ~= rooms[uid].exit_locks[chosen_exit] then
      dbCheckExecute(string.format ([[
         UPDATE exits SET level = %s WHERE dir = %s AND fromuid = %s;
         ]],
         fixsql (exit_level),
         fixsql (chosen_exit), -- direction (eg. "n")
         fixsql (uid) -- from current room
      ))

      mapper.mapprint ("Set level lock on exit", available [chosen_exit], "from room", uid, "to be", exit_level, "in database.")
   else
      mapper.mapprint ("Level lock unchanged for exit '"..chosen_exit.."'.")
   end

   -- update in-memory table
   rooms[uid].exit_locks[chosen_exit] = exit_level
   mapper.draw (current_room)

end -- room_lock_exit

function room_click (uid, flags)

   -- check we got room at all
   if not uid then
      return nil
   end -- if

   -- look it up
   local room = rooms [uid]

   -- not cached - see if in database
   if not room then
      room = load_room_from_database (uid)
      rooms [uid] = room -- cache for later
   end -- not in cache

   if not room then
      return
   end -- if still not there

   local handlers = {
      { name = "Edit Note", func = room_edit_note} ,
      { name = "Edit Terrain Colour", func = room_edit_terrain_colour} ,
      { name = "-", } ,
      { name = "Add Exit", func = room_add_exit} ,
      { name = "Change Exit", func = room_change_exit} ,
      { name = "Change Exit Level Lock", func = room_lock_exit} ,
      { name = "-", },
      { name = "Delete Exit", func = room_delete_exit},
      { name = "Delete Room", func = room_purgeroom}
--      { name = "-", } ,
      } -- handlers

   local t, tf = {}, {}
   for _, v in pairs (handlers) do
      table.insert (t, v.name)
      tf [v.name] = v.func
   end -- for

   rc, a, b, c = CallPlugin("60840c9013c7cc57777ae0ac", "getCurrentState")
   if rc == 0 and a == true then
      if b == 1 then
         table.insert(t,"-")
         table.insert(t,"Show Continent Bigmap")
      elseif c == 1 then
         table.insert(t,"-")
         table.insert(t,"Merge Continent Bigmap Into GMCP Mapper")
      end
   end

   local choice = WindowMenu (mapper.win,
                        WindowInfo (mapper.win, 14),
                        WindowInfo (mapper.win, 15),
                        table.concat (t, "|"))

   local f = tf [choice]

   if f then
      f (room, uid)
   elseif choice == "Show Continent Bigmap" then
      Execute("bigmap on")
   elseif choice == "Merge Continent Bigmap Into GMCP Mapper" then
      Execute("bigmap merge")
   end -- if handler found

end -- room_click

auto_backup_count = tonumber(GetVariable("auto_backup_count")) or 0
function rotate_backups (manual)
   if (manual) then
      os.remove(firstBackup.."_Manual_oldest")
      os.remove(firstBackup.."_Manual_oldest.zip")
      os.rename(firstBackup.."_Manual_older", firstBackup.."_Manual_oldest")
      os.rename(firstBackup.."_Manual_older.zip", firstBackup.."_Manual_oldest.zip")
      os.rename(firstBackup.."_Manual_old", firstBackup.."_Manual_older")
      os.rename(firstBackup.."_Manual_old.zip", firstBackup.."_Manual_older.zip")
      os.rename(firstBackup.."_Manual", firstBackup.."_Manual_old")
      os.rename(firstBackup.."_Manual.zip", firstBackup.."_Manual_old.zip")
      os.rename(firstBackup, firstBackup.."_Manual")
      os.rename(firstBackup..".zip", firstBackup.."_Manual.zip")
   else
      local t = utils.readdir (firstBackup.."_Automatic*")
      local oldest_exists = false
      local olderer_exists = false
      local older_exists = false
      if t ~= nil then
         local oldest_string = sanitize_filename(WorldName())..".db.Backup_Automatic_oldest"
         local olderer_string = sanitize_filename(WorldName())..".db.Backup_Automatic_olderer"
         local older_string = sanitize_filename(WorldName())..".db.Backup_Automatic_older"
         for k,v in pairs(t) do
            if string.find(k,oldest_string) then
               oldest_exists = true
            elseif string.find(k,olderer_string) then
               olderer_exists = true
            elseif string.find(k,older_string) then
               older_exists = true
            end
         end
      end
      if not (oldest_exists and olderer_exists and older_exists) then
         auto_backup_count = 1
      end
      if oldest_exists == false or auto_backup_count == 84 then
         os.remove(firstBackup.."_Automatic_oldest")
         os.remove(firstBackup.."_Automatic_oldest.zip")
         os.rename(firstBackup.."_Automatic_olderer", firstBackup.."_Automatic_oldest")
         os.rename(firstBackup.."_Automatic_olderer.zip", firstBackup.."_Automatic_oldest.zip")
      end
      if oldest_exists == false or olderer_exists == false or auto_backup_count % 28 == 0 then
         os.remove(firstBackup.."_Automatic_olderer")
         os.remove(firstBackup.."_Automatic_olderer.zip")
         os.rename(firstBackup.."_Automatic_older", firstBackup.."_Automatic_olderer")
         os.rename(firstBackup.."_Automatic_older.zip", firstBackup.."_Automatic_olderer.zip")
      end
      if oldest_exists == false or olderer_exists == false or older_exists == false or auto_backup_count % 7 == 0 then
         os.remove(firstBackup.."_Automatic_older")
         os.remove(firstBackup.."_Automatic_older.zip")
         os.rename(firstBackup.."_Automatic_old", firstBackup.."_Automatic_older")
         os.rename(firstBackup.."_Automatic_old.zip", firstBackup.."_Automatic_older.zip")
      end
      os.remove(firstBackup.."_Automatic_old")
      os.remove(firstBackup.."_Automatic_old.zip")
      os.rename(firstBackup.."_Automatic", firstBackup.."_Automatic_old")
      os.rename(firstBackup.."_Automatic.zip", firstBackup.."_Automatic_old.zip")
      os.rename(firstBackup, firstBackup.."_Automatic")
      os.rename(firstBackup..".zip", firstBackup.."_Automatic.zip")
      if auto_backup_count == 84 then
         auto_backup_count = 1
         SetVariable("auto_backup_count",auto_backup_count)
      end
   end
end

function automatic_backup()
   if fighting_state == true then
      AddTimer("backup_timer", 0, 0, 5, "", timer_flag.Replace + timer_flag.Enabled + timer_flag.ActiveWhenClosed, "automatic_backup")
      print("Mapper database automatic backup delayed due to combat. Will try again in 5 seconds.")
   else
      AddTimer("backup_timer", 23, 59, 59, "", timer_flag.Replace + timer_flag.Enabled + timer_flag.ActiveWhenClosed, "automatic_backup")
      auto_backup_count = auto_backup_count + 1
      backup_databases(false)
      SetVariable("auto_backup_count",auto_backup_count)
      SetVariable("last_auto_backup", os.time())
   end
end

function manual_backup()
   backup_databases(true)
end

function sanitize_filename(str)
   str = string.gsub(str, "[^%w%s()_-]", "")
   return Trim(str)
end

function quote(str)
   return "\""..str.."\""
end

function checkDatabaseIntegrity()
   Note("CHECKING INTEGRITY")
   Repaint()
   -- If needed, force wal_checkpoint databases to make sure everything gets written out
   -- this is a harmless no-op if not using journal_mode=WAL
   dbCheckExecute("PRAGMA wal_checkpoint(FULL);")
   local integrityCheck = true
   for row in db:nrows("PRAGMA quick_check;") do
      tprint(row)
      -- older sqlite returns "integrity_check" column, newer "quick_check" - we must check both to stay compatible
      if row.quick_check ~= "ok" and row.integrity_check ~= "ok" then
         integrityCheck = false
      end
   end
   if not integrityCheck then
      Note("FAILED INTEGRITY CHECK. CLOSE MUSHCLIENT AND RESTORE A KNOWN GOOD DATABASE BACKUP IMMEDIATELY.")
      utils.msgbox("FAILED MAPPER DB INTEGRITY CHECK. CLOSE MUSHCLIENT AND RESTORE A KNOWN GOOD DATABASE BACKUP IMMEDIATELY.", "Error!", "ok", "!", 1)
      return false
   end
   Note("INTEGRITY CHECK PASSED")
   return true
end

function backup_databases(manual)
   ColourNote("red", "", "Automatic backups are disabled in this experimental version, you would need to grand file IO privileges in your LUA sandbox");
   -- in_backup = true
   -- local success = false
   -- Note("PERFORMING "..((manual and "MANUAL") or "AUTOMATIC").." DATABASE BACKUP. DON'T TOUCH ANYTHING!")
   -- if not checkDatabaseIntegrity() then
   --    Note("ABORTING CURRENT BACKUP")
   --    Note("")
   --    Repaint()
   --    db = assert (sqlite3.open(worldPath..".db")) -- try to re-open the database anyway
   --    in_backup = false
   --    CorruptionAlert()
   --    return
   -- end
   -- Note("BACKING UP DATABASE")
   -- Repaint()
   --
   -- backupPath = GetInfo(66).."db_backups\\"..sanitize_filename(WorldName())
   -- firstBackup = backupPath..".db.Backup"
   --
   -- local ffi = require("ffi")
   -- ffi.cdef[[
   -- bool CreateDirectoryA(const char *lpPathName, void *lpSecurityAttributes);
   -- bool CopyFileA(const char* lpExistingFileName, const char * lpNewFileName, bool bFailIfExists);
   -- unsigned long GetLastError(void);
   -- ]]
   --
   -- succ = ffi.C.CreateDirectoryA(GetInfo(66).."db_backups\\", nil)
   -- err_no = ffi.C.GetLastError()
   -- if succ == false and err_no ~= 183 and err_no ~= 127 then
   --    -- error
   --    ColourNote("yellow","red", "ERROR ("..err_no..") trying to CreateDirectory: "..GetInfo(66).."db_backups\\\n")
   -- else
   --    -- successfully created the backup directory
   --    db:close() -- always close the database before copying
   --
   --    -- make new backup
   --    if use_compression == 1 then

   --       -- use pushd/popd here because cd can't @!#($$# access UNC directory paths
   --       local n = GetInfo(66).."aard_package_temp_file.txt" -- temp file for catching os.execute output
   --       local execute_string = "pushd "..quote(GetInfo(66)).." & zip -j -v -T "..quote(firstBackup..".zip").." "..quote(worldPath..".db").." >"..quote(n).." 2>&1 & popd"
   --       os.execute(execute_string)
   --       -- It's not so simple to catch errors from os.execute, so just display the system output here
   --       local lines = {}
   --       for line in io.lines (n) do
   --          table.insert(lines,line)
   --       end
   --       os.remove (n) -- remove temp file

   --       if not lines[#lines] or not string.find(lines[#lines], "zip OK") then
   --          -- something went wrong with the compression
   --          -- we expect to see some lines with the last line showing a passing test
   --          ColourNote("yellow","red", "ERROR executing system command: "..execute_string.."\n")
   --          for i,v in ipairs(lines) do
   --             ColourNote("yellow","red",v) -- flaming output
   --          end
   --          -- failure
   --       else
   --          for i,v in ipairs(lines) do
   --             Note(v) -- less intense output
   --          end
   --          success = true
   --       end
   --    else
   --       -- no compression, just copy
   --       succ = ffi.C.CopyFileA(worldPath..".db", firstBackup, false)
   --       err_no = ffi.C.GetLastError()
   --       if succ == false then
   --          ColourNote("yellow","red", "ERROR ("..err_no..") trying to copy database from '"..worldPath..".db' to '"..firstBackup.."'")
   --       else
   --          success = true
   --       end
   --    end
   -- end
   --
   -- if success then
   --    rotate_backups(manual) -- rotate backup folders (obviously)
   --    Note("FINISHED DATABASE BACKUP. YOU MAY NOW GO BACK TO MUDDING.")
   -- else
   --    Note("ABORTING BACKUP.")
   --    CorruptionAlert()
   -- end
   -- Note("")
   -- db = assert (sqlite3.open(worldPath..".db")) -- re-open database
   -- Repaint()
   -- in_backup = false
end

function CorruptionAlert()
   Note("")
   Note("WARNING, PLEASE READ: http://code.google.com/p/aardwolfclientpackage/wiki/GMCPmapper#Database_Corruption")
   Note("If the information there does not help you 100%, then try asking on the Tech channel and report this error to Fiendish.")
   Note("")
end

-- ec, areaKeys = CallPlugin("b6eae87ccedd84f510b74714", "getkeyword", "The Broken Halls of Horath") puts "horath" into areaKeys
-- ec, areaKeys = CallPlugin("b6eae87ccedd84f510b74714", "getkeyword", "halls") puts "damned,horath,vanir" into areaKeys
function getkeyword(area)
   local keys = {}
   for row in db:nrows(string.format("SELECT uid FROM areas WHERE name LIKE %s;", fixsql("%"..area.."%"))) do
      table.insert(keys,row.uid);
   end -- finding areas
   return table.concat(keys, ",")
end

function fix_exits_table()
   -- The original database implementation for exits was naive and broken. We want to fix it up here.
   -- Unfortunately, sqlite requires a little dance of table dropping for this to happen.
   local level_column_exists = false
   for a in db:nrows "PRAGMA table_info('exits')" do
      if a["name"] == "level" then
         level_column_exists = true
      end
   end

   local query = [[
   BEGIN TRANSACTION;

   ALTER TABLE exits RENAME TO exits_backup;

   CREATE TABLE exits (
      dir         TEXT    NOT NULL, -- direction, eg. "n", "s"
      fromuid     TEXT    NOT NULL, -- exit from which room (in rooms table)
      touid       TEXT    NOT NULL, -- exit to which room (in rooms table)
      level       STRING  NOT NULL DEFAULT '0', -- minimum level to make use of this exit
      date_added  DATE,             -- date added to database
      PRIMARY KEY(fromuid, dir),
      FOREIGN KEY(fromuid) REFERENCES rooms(uid)
   );

   INSERT OR REPLACE INTO exits(dir,fromuid,touid,date_added]]..(((level_column_exists == false) and "") or ",level")..[[) SELECT dir, fromuid, touid, date_added]]..(((level_column_exists == false) and "") or ", level")..[[ FROM exits_backup;
   DROP TABLE exits_backup;
   CREATE INDEX IF NOT EXISTS fromuid_index ON exits (fromuid);
   CREATE INDEX IF NOT EXISTS touid_index   ON exits (touid);
   COMMIT;
   ]]
   dbCheckExecute(query)
end

function OnPluginInstall ()
   configs = {}  -- in case not found

   fonts = utils.getfontfamilies ()

   -- if not there already, add it
   if not fonts.Dina then
      AddFont (GetInfo (66) .. "\\Dina.fon")
   end -- if Dina not installed

   -- get saved configuration
   assert (loadstring (GetVariable ("configs") or "")) ()

   -- allow for additions to configs
   for k, v in pairs (default_config) do
      configs [k] = configs [k] or v
   end -- for

   -- initialize mapper engine
   mapper.init { findpath = findpath,
      config = configs,            -- colours, timing etc.
      get_room = get_room,        -- get_room (uid) called to get room info
      show_help = OnHelp,         -- to show help
      room_click = room_click,    -- called on RH click on room square
      timing = show_timing,       -- want to see timing
      show_completed = show_completed,  -- want to see "Speedwalk completed." message
      show_other_areas = show_other_areas,  -- want to see areas other than the current one?
      show_up_down = show_up_down,          -- want to follow up/down exits?
      show_area_exits = show_area_exits,    -- want to see area exits?
      speedwalk_prefix = speedwalk_prefix,  -- how to speedwalk
   }

   -- open databases on disk
   worldPath = GetInfo(66)..sanitize_filename(WorldName())

   db = assert (sqlite3.open(worldPath..".db"))
   db:busy_timeout(100)

   if not checkDatabaseIntegrity() then
      CorruptionAlert()
      return
   end

   for row in db:nrows("PRAGMA user_version") do
      db_user_version = row.user_version
   end

   -- Only go through the structure creation if we haven't done it already
   -- to save time at startup.
   if db_user_version < 2 then
      create_tables()
   end

   -- Database version 3 used to preload terrains, but now we dynamically
   -- request the terrains list from the server with sendgmcp request sectors
   -- se we don't need it anymore. Now we just skip from 2 to 4.

   if db_user_version < 4 then
      -- add bookmarks and terrain tables to the main db since we're
      -- ditching the second db file
      dbCheckExecute([[
      CREATE TABLE IF NOT EXISTS bookmarks (
         id          INTEGER PRIMARY KEY AUTOINCREMENT,
         uid         TEXT    NOT NULL,   -- vnum of room
         notes       TEXT,               -- user notes
         date_added  DATE,               -- date added to database
         UNIQUE (uid)
      );
      CREATE TABLE IF NOT EXISTS terrain (
         id          INTEGER PRIMARY KEY AUTOINCREMENT,
         name        TEXT    NOT NULL,   -- terrain name
         color       INTEGER,            -- RGB code
         date_added  DATE,               -- date added to database
         UNIQUE (name)
      );
      ]])
   end

   if db_user_version < 5 then
      check_rooms_flags()
   end

   if db_user_version < 6 then
      -- original database name for wayhouse was missing the apostrophe
      dbCheckExecute([[
      update areas set name="The Adventurers' Wayhouse" where uid="wayhouse";
      ]])
   end

   if db_user_version < 7 then
      fix_exits_table()
      dbCheckExecute([[
      CREATE TABLE IF NOT EXISTS storage (
         name        TEXT NOT NULL,
         data        TEXT NOT NULL,
         PRIMARY KEY (name)
      );
      ]])
      loadstring(GetVariable("bounce_recall") or "")()
      loadstring(GetVariable("bounce_portal") or "")()
      if bounce_recall then
         dbCheckExecute(string.format("INSERT OR REPLACE INTO storage (name, data) VALUES (%s,%s);", fixsql("bounce_recall"), fixsql(serialize.save("bounce_recall"))))
      end
      if bounce_portal then
         dbCheckExecute(string.format("INSERT OR REPLACE INTO storage (name, data) VALUES (%s,%s);", fixsql("bounce_portal"), fixsql(serialize.save("bounce_portal"))))
      end
   end

   -- this should always be the last stage in db schema updates
   if db_user_version < 8 then
      dbCheckExecute("VACUUM;")
   end

   -- update db version
   dbCheckExecute("PRAGMA user_version = 8;")

   -- b_b, err, erm = io.open(worldPath.."_bookmarks.db", "r")
   -- if b_b ~= nil then
   --    io.close(b_b)
   --    ColourNote("white", "blue", "Found obsolete bookmarks file "..sanitize_filename(WorldName()).."_bookmarks.db.")
   --    ColourNote("white", "blue", "Merging into the main database file.")
   --    ColourNote("white", "blue", sanitize_filename(WorldName()).."_bookmarks.db --> "..sanitize_filename(WorldName())..".db")
   --    db_bm = assert (sqlite3.open(worldPath.."_bookmarks.db"))

   --    local bm_found = false
   --    for row in db_bm:nrows("SELECT name FROM sqlite_master WHERE type='table' AND name='bookmarks';") do
   --       bm_found = true
   --    end
   --    local tr_found = false
   --    for row in db_bm:nrows("SELECT name FROM sqlite_master WHERE type='table' AND name='terrain';") do
   --       tr_found = true
   --    end
   --    if bm_found then
   --       for row in db_bm:nrows("SELECT * FROM bookmarks;") do
   --          dbCheckExecute(string.format("INSERT OR REPLACE INTO bookmarks (uid, notes, date_added) VALUES (%s, %s, DATETIME('NOW'));",
   --          fixsql(row.uid),fixsql(row.notes)))
   --       end
   --    end
   --    if tr_found then
   --       for row in db_bm:nrows("SELECT * FROM terrain;") do
   --          dbCheckExecute(string.format("INSERT OR REPLACE INTO terrain (name, color, date_added) VALUES (%s, %i, DATETIME('NOW'));",
   --          fixsql(row.name),row.color))
   --       end
   --    end
   --
   --    db_bm:close()
   --    ok, err = os.remove(worldPath.."_bookmarks.db")
   --    if not ok then
   --       ColourNote("white","red", "Error trying to delete obsolete file: "..worldPath.."_bookmarks.db. Please delete it manually.")
   --    end
   -- end

   -- grab all area names
   for row in db:nrows("SELECT * FROM areas") do
      area = {
         name = row.name,
         texture = row.texture,
         color = row.color
      }
      areas [row.uid] = area
   end   -- finding areas

   -- grab all user terrain info
   for row in db:nrows("SELECT * FROM terrain") do
      user_terrain_colour [row.name] = row.color
   end -- finding terrains

   -- grab all environment names
   for row in db:nrows("SELECT * FROM environments") do
      environments [tonumber (row.uid)] = row.name
      terrain_colours [row.name] = tonumber (row.color)
   end -- finding environments

   --~    bounce_recall = {dir="home",uid=21335}
   --~    bounce_portal = {dir="enter",uid=26151}
   for row in db:nrows("SELECT * FROM storage") do
      if row.name == "bounce_portal" or row.name == "bounce_recall" then
         loadstring(row.data or "")()
      end
   end

   if IsConnected() then
      OnPluginConnect()
      Send_GMCP_Packet("request char")
      Send_GMCP_Packet("request room")
   end

   -- if disabled last time, stay disabled
   if GetVariable ("enabled") == "false" then
      ColourNote ("yellow", "", "Warning: Plugin " .. GetPluginName ().. " is currently disabled.")
      check (EnablePlugin(GetPluginID (), false))
      return
   end -- they didn't enable us last time

   last_auto_backup = tonumber(GetVariable("last_auto_backup")) or 0
   SetTimerOption("backup_timer", "enabled", tonumber(GetVariable("backup_timer_enabled")) or 1)
   if GetTimerOption("backup_timer", "enabled") == 1 then
      if (os.time()-last_auto_backup) >= 86401 then
         Note("It looks like it has been more than 24 hours since your last automatic mapper database backup!")
         Note("Forcing an automatic backup now...")
         Note("")
         Repaint()
         automatic_backup()
      else
         local seconds = 86400-(os.time()-last_auto_backup)
         local hours = math.floor(seconds/3600)
         seconds = seconds - hours*3600
         local minutes = math.floor(seconds/60)
         seconds = math.floor(seconds - minutes*60)
         -- replace the timer with a new one that has the right time
         AddTimer("backup_timer", hours, minutes, seconds, "", timer_flag.Replace + timer_flag.Enabled + timer_flag.ActiveWhenClosed + timer_flag.OneShot, "automatic_backup")
      end
   end
end -- OnPluginInstall

function OnPluginEnable ()
   mapper.show ()
   if not db:isopen() then
      db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
   end
   OnPluginSaveState()
end -- OnPluginEnable

function dbCheckExecute(query)
   local code = db:exec(query)
--~ failed attempt to make concurrent sessions viable
--~    if code == 5 or code == 6 then -- SQLITE_BUSY or SQLITE_LOCKED (oops?)
--~       wait.make (function()
--~          local code = 5
--~          local count = 0
--~          while ((code == 5 or code == 6) and count < 20) do
--~             db:exec ("ROLLBACK")
--~             wait.time(.1)
--~             code = db:exec(query)
--~             count = count + 1
--~          end
--~          dbcheck(code, query)
--~       end)
--~    else
      dbcheck(code, query)
--~    end
end

-- hide window on removal
function OnPluginDisable ()
   OnPluginSaveState()
   mapper.hide ()
   -- close databases
   if db:isopen() then
      db:close()
   end
end -- OnPluginDisable

function OnPluginClose ()
   -- if enabled
   if GetPluginInfo(GetPluginID(), 17) then
      OnPluginDisable()
   end -- if enabled
   WindowDelete(mapper.win)
end -- OnPluginClose

function OnPluginSaveState ()
   SetVariable ("enabled", tostring (GetPluginInfo (GetPluginID (), 17)))
   if configs.SCAN.depth < temp_scan_depth then
      -- then we probably caught ourselves in a botched run or something
      configs.SCAN.depth = temp_scan_depth
   end
   mapper.save_state ()
   SetVariable("config","") -- wipe out the old config table
   SetVariable ("configs", "configs = " .. serialize.save_simple (configs))
   SetVariable("quick_mode", (quick_mode and "1") or "0")
   SetVariable("shownotes", (shownotes and "1") or "0")

   -- close and reopen database
   if db:isopen() then
      db:close()
      db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
   end
end -- OnPluginSaveState

terrain_colours = {}

-- ANSI colours lookup (for terrain_colours)
colour_lookup = {
   [0] =   ColourNameToRGB  "black",
   [1] =   ColourNameToRGB  "maroon",
   [2] =   ColourNameToRGB  "green",
   [3] =   ColourNameToRGB  "olive",
   [4] =   ColourNameToRGB  "navy",
   [5] =   ColourNameToRGB  "purple",
   [6] =   ColourNameToRGB  "teal",
   [7] =   ColourNameToRGB  "silver",
   [8] =   ColourNameToRGB  "gray",
   [9] =   ColourNameToRGB  "red",
   [10] =  ColourNameToRGB  "lime",
   [11] =  ColourNameToRGB  "yellow",
   [12] =  ColourNameToRGB  "blue",
   [13] =  ColourNameToRGB  "magenta",
   [14] =  ColourNameToRGB  "cyan",
   [15] =  ColourNameToRGB  "white",
} -- end of colour_lookup

running = false
temp_scan_depth = 4

function activate_running(run)
   running = run
   if running then
      temp_scan_depth = mapper.configs.SCAN.depth
      mapper.configs.SCAN.depth = 4  -- or whatever
   else
      mapper.configs.SCAN.depth = temp_scan_depth
   end
   mapper.draw(current_room)
end

function compareTables(primary, secondary)
   for i,v in pairs(primary) do
      if secondary[i] ~= v then
         return false
      end
   end
   return true
end

-- functions for handling Aardwolf color codes
dofile (GetPluginInfo (GetPluginID(), 20) .. "brutus_colors.lua")
bigmap_override = false
function override_continents(override)
   if override == "true" then
      bigmap_override = true
   elseif override == "false" then
      bigmap_override = false
   end
   mapper.halt_drawing(bigmap_override and current_room_is_cont)
end

function noportal_room()
   if current_room ~= nil then
      if rooms[current_room] ~= nil then
         if rooms[current_room].noportal ~= 1 then
            Note('marking room ', current_room, ' noportal')
            rooms[current_room].noportal = 1
            dbCheckExecute("BEGIN TRANSACTION;")
            save_room_to_database(current_room, rooms[current_room])
            dbCheckExecute("COMMIT;")
         end
      end
   end
end

function norecall_room()
   if current_room ~= nil then
      if rooms[current_room] ~= nil then
         if rooms[current_room].norecall ~= 1 then
            Note('marking room ', current_room, ' norecall')
            rooms[current_room].norecall = 1
            dbCheckExecute("BEGIN TRANSACTION;")
            save_room_to_database(current_room, rooms[current_room])
            dbCheckExecute("COMMIT;")
         end
      end
   end
end

function draw_other(name, line, wildcards)
   current_room = wildcards[1]
   mapper.draw(current_room)
end

function got_gmcp_room()
   local room_number = gmcpval("num")
   if not(room_number) then
      return
   end

   if current_room_is_cont ~= (gmcpval("coord.cont") == "1") then
      current_room_is_cont = (gmcpval("coord.cont") == "1")
      mapper.halt_drawing(bigmap_override and current_room_is_cont)
   end

   gmcproom = {
      name = strip_colours(gmcpval("name")),
      area = gmcpval("zone"),
      building = 0,
      terrain = gmcpval("terrain"),
      info = gmcpval("details"),
      notes = "",
      x = gmcpval("coord.x"),
      y = gmcpval("coord.y"),
      z = 0,
      exits = {},
      exit_locks = {}
      }

   -- Try to accomodate closed clan rooms and other nomap rooms.
   -- We'll have to make some other changes elsewhere as well.
   if room_number == "-1" then
      room_number = "nomap_"..gmcproom.name.."_"..gmcproom.area
   end

   current_room = room_number

   local area_exists = false
   for n in db:nrows (string.format ("SELECT uid FROM areas where uid=%s", fixsql(gmcproom.area))) do
      area_exists = true
   end
   if not area_exists then
      Send_GMCP_Packet("request area")
   end

   local room = rooms [room_number]
   -- not cached - see if in database
   if not room then
      room = load_room_from_database (room_number)
   end -- not in cache

   if shownotes and room and room.notes and room.notes ~= "" then
      print("*** MAPPER NOTE *** ->",room.notes)
   end

   -- re-save if we got information that is different than before
   local same_exits = ((room and compareTables(gmcpdata.exits, room.exits)) or false)
   local same_area = ((room and (nilToStr(room.area) == nilToStr(gmcproom.area))) or false)
   if not room or nilToStr(room.name) ~= nilToStr(gmcproom.name) or
                  nilToStr(room.terrain) ~= nilToStr(gmcproom.terrain) or
                  nilToStr(room.info) ~= nilToStr(gmcproom.info) or
                  same_area == false or
                  same_exits == false then
      if same_area then
--          print("same area")
--          if room then
--             print("ROOM")
--             tprint(room)
--          end
--          print("GMCPROOM")
--          tprint(gmcproom)

         gmcproom.exits = (room.exits or {})
         gmcproom.exit_locks = (room.exit_locks or {})
         gmcproom.notes = nilToStr(room.notes)
         gmcproom.noportal = (room.noportal or 0)
         gmcproom.norecall = (room.norecall or 0)
      elseif room and nilToStr(room.area) ~= "" and areas[nilToStr(room.area)] then
         -- replacement area
--         print("different area")
--         if room then
--            print("ROOM")
--            tprint(room)
--         end
--         print("GMCPROOM")
--         tprint(gmcproom)

         mapper.mapprint("This room has moved areas. You should 'mapper purgezone "..nilToStr(room.area).."' if this new area replaces it.")
         map_purgeroom (nilToStr(room_number), gmcproom.area)
      else
         -- brand new area
--         print("new area")
         gmcproom.exits = {}
         gmcproom.exit_locks = {}
         gmcproom.notes = ""
         gmcproom.noportal = 0
         gmcproom.norecall = 0
      end
      dbCheckExecute("BEGIN TRANSACTION;")
      local success = save_room_to_database(room_number, gmcproom)
      if success then
         rooms[room_number] = gmcproom
         if not same_exits or not same_area then
            save_room_exits(room_number)
         end
      end
      dbCheckExecute("COMMIT;")

      if not success then
         return
      end
   end -- if room not there

   mapper.draw(room_number)

   if expected_exit == "0" and from_room then
      fix_up_exit ()
   end -- exit was wrong

   return
end

function update_gmcp_area()

   local areaid = gmcpval("id")
   local areaname = gmcpval("name")
   local texture = gmcpval("texture")
   local color = gmcpval("col")
   local x,y,z = gmcpval("x"),gmcpval("y"),gmcpval("z")

   dbCheckExecute (string.format (
      "REPLACE INTO areas (uid, name, date_added, texture, color) VALUES (%s, %s, DATETIME('NOW'), %s, %s);",
      fixsql (areaid),
      fixsql (areaname),
      fixsql (texture),
      fixsql (color)
   ))

   area = {
      name = areaname,
      texture = texture,
      color = color
   }
   areas [areaid] = area

   Send_GMCP_Packet("request room") -- Just got a new area update. Now check for our room again.
   return
end


function save_room_exits(uid)
   if rooms[uid] == nil then
      return
   end
   if gmcpdata.exits ~= nil then
      for dir,touid in pairs(gmcpdata.exits) do
         if dir then
            dbCheckExecute (string.format ([[
               INSERT OR REPLACE INTO exits (dir, fromuid, touid, date_added)
               VALUES (%s, %s, %s, DATETIME('NOW'));
               ]], fixsql  (dir),  -- direction (eg. "n")
               fixsql  (uid),  -- from current room
               fixsql  (touid) -- destination room
            ))

            if show_database_mods then
               mapper.mapprint ("Added exit: ", dir, "from room: ",uid, "to room: ", touid, " to database.")
            end -- if

            if rooms[uid].exits[dir] ~= touid then
               rooms[uid].exit_locks[dir] = "0"
            end
            rooms[uid].exits[dir] = touid
         else
            mapper.maperror ("Cannot make sense of:", exit)
         end -- if can decode
      end -- for each exit
   end -- have exits.
end -- save_room_exits

function update_gmcp_sectors()
   dbCheckExecute("BEGIN TRANSACTION;")
   dbCheckExecute ("DELETE FROM environments;")
   for i,v in pairs(gmcp_sectors_list.sectors) do
      dbCheckExecute( string.format([[
      INSERT OR REPLACE INTO environments VALUES (%s,%s,%s,%s,DATETIME('NOW'));
      ]], i, v.id, fixsql(v.name), v.color))
   end
   dbCheckExecute("COMMIT;")

   for row in db:nrows("SELECT * FROM environments") do
      environments [tonumber (row.uid)] = row.name
      terrain_colours [row.name] = tonumber (row.color)
   end -- finding environments

   mapper.draw (current_room)
end

function OnPluginBroadcast (msg, id, name, text)
   if in_backup == true then
      return
   end
   if id == "3e7dedbe37e44942dd46d264" then -- gmcphandler
      if (text == "room.info") then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
         luastmt = "gmcpdata = " .. gmcparg
         assert (loadstring (luastmt or "")) ()
         got_gmcp_room()
      end -- if room.info

      if (text == "room.wrongdir") then
         mapper.cancel_speedwalk()
      end -- wrongdir

      if (text == "char.base") then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.base")
         luastmt = "gmcpdata = " .. gmcparg
         assert (loadstring (luastmt or "")) ()
         mytier = tonumber(gmcpdata.tier)
      end

      if (text == "char.status") then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.status")
         luastmt = "gmcpdata = " .. gmcparg
         assert (loadstring (luastmt or "")) ()
         mylevel = tonumber(gmcpdata.level)
         myState = tonumber(gmcpdata.state)
         if running == false and myState == 12 then
            activate_running(true)
         elseif running == true and myState ~= 12 then
            activate_running(false)
         end
         if myState == 8 then
            fighting_state = true
         else
            fighting_state = false
         end
      end -- running

      if (text == "room.area") then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.area")
         luastmt = "gmcpdata = " .. gmcparg
         assert (loadstring (luastmt or "")) ()
         update_gmcp_area()
      end

      if (text == "room.sectors") then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.sectors")
         luastmt = "gmcp_sectors_list = " .. gmcparg
         assert (loadstring (luastmt or "")) ()
         update_gmcp_sectors()
      end
   elseif (id == "462b665ecb569efbf261422f" and msg==996 and text == "re-register z") then
      CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", mapper.win)
   end
end

function quick_mode_toggle(name, line, wildcards)
   if (wildcards[2] ~= "") then
      quick_mode = (wildcards[2] == "on")
   end
   Note("")
   if quick_mode then
      Note("QUICKLIST is ON: Lists of found targets will display immediately without sorting by distance.")
   else
      Note("QUICKLIST is OFF: Lists of found targets will pathfind each result and sort them by distance.")
   end
   Note("")
end

function shownote_toggle(name, line, wildcards)
   if (wildcards[2] ~= "") then
      shownotes = (wildcards[2] == "on")
   end
   Note("")
   if shownotes then
      Note("SHOWNOTES is ON: Notes added to rooms will display automatically upon entrance.")
   else
      Note("SHOWNOTES is OFF: Notes added to rooms will NOT display automatically.")
   end
   Note("")
end

function map_area (name, line, wildcards)

   uid = mapper.current_room

   -- check we got room at all
   if not uid then
      print("I do not know your room! Try typing 'LOOK' first.")
      return
   end -- if

   -- look it up
   local ourroom = rooms [uid]

   -- not cached - see if in database
   if not ourroom then
      ourroom = load_room_from_database (uid)
      rooms [uid] = ourroom -- cache for later
   end -- not in cache

   if not ourroom then
      print("AREA ERROR: The area has not been initialized yet. Please try again in a second.")
      return
   end -- if

   local area = rooms[uid].area

   local rooms = {}
   local count = 0

   local key = Trim(wildcards[1])
   local name = "%"..key.."%"
   if string.sub(key,1,1) == "\"" and string.sub(key,-1) == "\"" then
      name = Trim(string.sub(key,2,-2))
   end
   for row in db:nrows(string.format ("SELECT uid, name, area FROM rooms WHERE trim(name) LIKE %s and area = %s", fixsql(name), fixsql(area))) do
      table.insert(rooms,{uid=row.uid, reason=true})
      count = count + 1
   end   -- finding room

   -- see if nearby

   mapper.find (name,
      rooms,
      50,
      show_vnums,  -- show vnum?
      count,      -- how many to expect
      false,       -- don't auto-walk
      nil,
      quick_mode
   )

end -- map_area


function map_find (name, line, wildcards)

   local rooms = {}
   local count = 0

   -- find matching rooms using FTS3
   local name = "%"..wildcards[1].."%"

   if string.sub(wildcards[1],1,1) == "\"" and string.sub(wildcards[1],-1) == "\"" then
      name = string.sub(wildcards[1],2,-2)
   end
   for row in db:nrows(string.format ("SELECT uid, name FROM rooms_lookup WHERE rooms_lookup.name LIKE %s", fixsql (name))) do
      table.insert(rooms, {uid=row.uid, reason=true})
      count = count + 1
   end   -- finding room

   -- see if nearby
   mapper.find (name,
      rooms,  -- function
      50,
      show_vnums,  -- show vnum?
      count,      -- how many to expect
      false,       -- don't auto-walk
      nil,
      quick_mode
   )
end -- map_find


function map_find_special(which_ones, which_area)

   local wanted_items = {}

   for _, v in ipairs (which_ones) do
      wanted_items [v:lower ()] = true
   end

   local rooms = {}
   local count = 0

   res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
   luastmt = "gmcpdata = " .. gmcparg
   assert(loadstring (luastmt or "")) ()
   local current_area = gmcpval("zone")

   area = Trim(which_area or "")
   if area == "" then
      mapper.mapprint("Searching all areas")
      query = "SELECT uid, name, info FROM rooms WHERE rooms.info IS NOT NULL"
   else
      if area == "here" then
         area = current_area
         mapper.mapprint("Searching current area")
      else
         area = "%"..area.."%"
         mapper.mapprint("Searching areas that partially match %"..area.."%")
      end
      query = string.format("SELECT uid, name, info FROM rooms WHERE rooms.info IS NOT NULL AND lower(rooms.area) LIKE %s", fixsql(area))
   end -- if area

   -- build table of special places (with info in them)
   for row in db:nrows(query) do
      if row.info ~= "" then
         local wanted = false
         local t = {}
         for item in string.gmatch (row.info, "[^,]+") do
            if wanted_items [item:lower ()] then
               wanted = true
               table.insert (t, capitalize (item))
            end -- if
         end -- for
         if wanted then
            table.insert(rooms, {uid=row.uid, reason=table.concat(t, ", ")})
            count = count + 1
         end -- if
      end -- if
   end   -- finding room

   -- find such places
   mapper.find (table.concat(which_ones,","),
      rooms,
      0,
      show_vnums,  -- show vnum?
      count,      -- how many to expect
      false,       -- don't auto-walk
      nil,
      true         -- quick list
   )
end -- map_find_special

function map_shops (name, line, wildcards)
   map_find_special ({ "shop", "bank", }, wildcards[1])
end -- map_shops

function map_trainers (name, line, wildcards)
   map_find_special ({ "trainer", }, wildcards[1])
end -- map_trainers

function map_quests (name, line, wildcards)
   map_find_special ({ "questor", }, wildcards[1])
end -- map_quests

function map_healers (name, line, wildcards)
   map_find_special ({ "healer", }, wildcards[1])
end -- map_healers


function map_goto (name, line, wildcards)

   local wanted = string.match(wildcards[1], "^(nomap_.+)$") or tonumber(wildcards [1])
   if not wanted or (type(wanted) == "number" and  wanted < 0) then
      mapper.mapprint ("The mapper "..(((string.match(line, "^mapper walkto") ~= nil) and "walkto") or "goto").." command expects a room id as input.")
      return
   end
   wanted = tostring(wanted)
   if current_room and (wanted == current_room) then
      mapper.mapprint ("You are already in that room.")
      return
   end -- if

   -- find desired room
   mapper.find (nil,
      {{uid=wanted, reason=true}},
      0,
      show_vnums,  -- show vnum?
      1,          -- how many to expect
      true,        -- just walk there
      nil,
      nil,
      string.match(line, "^mapper walkto") ~= nil
   )
end -- map_goto

function map_where (name, line, wildcards)

   if not mapper.check_we_can_find () then
      return
   end -- if

   local wanted = tonumber(wildcards [1])

   if not wanted then
      mapper.mapprint ("The mapper where command expects a room id number as input.")
      return
   end

   if current_room and wanted == current_room then
      mapper.mapprint ("You are already in that room.")
      return
   end -- if

   local paths = {}
   local foundpath = findpath(current_room, wanted)
   if foundpath ~= nil then
      paths[wanted] = {path=foundpath, reason=true}
   end

   local uid, item = next (paths, nil) -- extract first (only) path

   -- nothing? room not found
   if not item then
      mapper.mapprint (string.format ("Room %s not found", wanted))
      return
   end -- if

   -- turn into speedwalk
   local speedwalk = mapper.build_speedwalk (item.path, speedwalk_prefix)

   -- display it
   if speedwalk ~= nil then
      mapper.mapprint (string.format ("Path to %s is:\n%s\n", wanted, speedwalk))
   else
      mapper.mapprint (string.format("You're IN room %s!", wanted))
   end
end -- map_where

function map_resume (name, line, wildcards)

   local wanted = tonumber(mapper.last_hyperlink_uid or mapper.last_speedwalk_uid)

   if not wanted then
      mapper.print "No outstanding speedwalks or hyperlinks."
      return
   end -- if nothing to do

   wanted = tostring(wanted)
   -- find desired room
   mapper.find (nil,
      {{uid=wanted,reason=true}},
      0,  -- function
      show_vnums,  -- show vnum?
      1,      -- how many to expect
      true    -- just walk there
   )
end -- map_resume

function map_notes (name, line, wildcards)

   local rooms = {}
   local count = 0
   local area = Trim(wildcards[2] or "")

   local q = string.format ("SELECT bookmarks.uid as uid, bookmarks.notes as notes FROM bookmarks")

   if area ~= "" then
      if area == "here" then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
         luastmt = "gmcpdata = " .. gmcparg
         assert(loadstring (luastmt or "")) ()
         area = gmcpval("zone")
         mapper.mapprint("Searching the current area")
      else
         mapper.mapprint("Searching areas that partially match '"..area.."'")
         area = "%"..area.."%"
      end
      q = q..",rooms where bookmarks.uid=rooms.uid and rooms.area like "..fixsql(area)
   else
      mapper.mapprint("Searching all areas")
   end

   -- build table of special places (with info in them)
   for row in db:nrows(q) do
      table.insert(rooms,{uid=row.uid, reason=row.notes})
      count = count + 1
   end   -- finding room

   -- find such places
   mapper.find ("[NOTE]",
      rooms,
      0,  -- function
      show_vnums,  -- show vnum?
      count,       -- how many to expect
      false,        -- don't auto-walk
      nil,
      true  -- quick list
   )
end -- map_notes

local bit = require("bit")

-- original findpath function idea contributed by Spartacus
function findpath(src, dst, noportals, norecalls)
   local depth = 0
   local max_depth = mapper.configs.SCAN.depth
   local room_sets = {}
   local rooms_list = {}
   local found = false
   local ftd = {}
   local f = ""
   local next_room = 0

   if type(src) ~= "number" then
      src = string.match(src, "^(nomap_.+)$") or tonumber(src)
   end
   if type(dst) ~= "number" then
      dst = string.match(dst, "^(nomap_.+)$") or tonumber(dst)
   end

   if src == dst or src == nil or dst == nil then
      return {}
   end

   src = tostring(src)
   dst = tostring(dst)

   table.insert(rooms_list, fixsql(dst))

   local visited = ""
   local main_status = GetInfo(53)
   while not found and depth < max_depth do
      SetStatus(main_status.." (searching depth "..depth..")")
      BroadcastPlugin (999, "repaint")
      depth = depth + 1
      if depth > 1 then
         ftd = room_sets[depth-1] or {}
         rooms_list = {}
         for k,v in pairs(ftd) do
            table.insert(rooms_list, fixsql(v.fromuid))
         end -- for from, to, dir
      end -- if depth

      -- prune the search space
      if visited ~= "" then
         visited = visited..","..table.concat(rooms_list, ",")
      else
         if noportals then
            visited = visited..fixsql("*")..","
         end
         if norecalls then
            visited = visited..fixsql("**")..","
         end
         visited = visited..table.concat(rooms_list, ",")
      end

      -- get all exits to any room in the previous set
      local q = string.format ("select fromuid, touid, dir from exits where touid in (%s) and fromuid not in (%s) and ((fromuid not in ('*','**') and level <= %s) or (fromuid in ('*','**') and level <= %s)) order by length(dir) asc",table.concat(rooms_list,","), visited,mylevel,mylevel+(mytier*10))
      local dcount = 0
      room_sets[depth] = {}
      for row in db:nrows(q) do
         dcount = dcount + 1
         -- ordering by length(dir) ensures that custom exits (always longer than 1 char) get
         -- used preferentially to normal ones (1 char)
         room_sets[depth][row.fromuid] = {fromuid=row.fromuid, touid=row.touid, dir=row.dir}
         if row.fromuid == "*" or (row.fromuid == "**" and f ~= "*" and f ~= src) or row.fromuid == src then
            f = row.fromuid
            found = true
            found_depth = depth
         end -- if src
      end -- for select

      if dcount == 0 then
         return -- there is no path from here to there
      end -- if dcount
   end -- while

   if found == false then
      return
   end

   -- We've gotten back to the starting room from our destination. Now reconstruct the path.
   local path = {}
   -- set ftd to the first from,to,dir set where from was either our start room or * or **
   ftd = room_sets[found_depth][f]

   if not rooms[src] then
      rooms[src] = load_room_from_database(src)
   end

   if (f == "*" and rooms[src].noportal == 1) or (f == "**" and rooms[src].norecall == 1) then
      if rooms[src].norecall ~= 1 and bounce_recall ~= nil then
         table.insert(path, bounce_recall)
      elseif rooms[src].noportal ~= 1 and bounce_portal ~= nil then
         table.insert(path, bounce_portal)
      else
         local jump_room, type = findNearestJumpRoom(src, dst, f)
         if not jump_room then
            return
         end
         local path, first_depth = findpath(src,jump_room, true, true) -- this could be optimized away by building the path in findNearestJumpRoom, but the gain would be negligible
         if bit.band(type, 1) ~= 0 then
            -- type 1 means just walk to the destination
            return path, first_depth
         else
            local second_path, second_depth = findpath(jump_room, dst)
            for i,v in ipairs(second_path) do
               table.insert(path, v)
            end
            return path, first_depth+second_depth
         end
      end
   end

   table.insert(path, {dir=ftd.dir, uid=ftd.touid})

   next_room = ftd.touid
   while depth > 1 do
      depth = depth - 1
      ftd = room_sets[depth][next_room]
      next_room = ftd.touid
-- this caching is probably not noticeably useful, so disable it for now
--      if not rooms[ftd.touid] then -- if not in memory yet, get it
--         rooms[ftd.touid] = load_room_from_database (ftd.touid)
--      end
      table.insert(path, {dir=ftd.dir, uid=ftd.touid})
   end -- while
   return path, found_depth
end -- function findpath

-- Very similar to findpath, but looks forwards instead of backwards (so only walks)
-- and stops at the nearest portalable or recallable room
function findNearestJumpRoom(src, dst, target_type)
   local depth = 0
   local max_depth = mapper.configs.SCAN.depth
   local room_sets = {}
   local rooms_list = {}
   local found = false
   local ftd = {}
   local destination = ""
   local next_room = 0
   local visited = ""
   local type = ""

   table.insert(rooms_list, fixsql(src))
   local main_status = GetInfo(53)
   while not found and depth < max_depth do
      SetStatus(main_status.." (searching jump depth "..depth..")")
      BroadcastPlugin (999, "repaint")
      depth = depth + 1

      -- prune the search space
      if visited ~= "" then
         visited = visited..","..table.concat(rooms_list, ",")
      else
         visited = table.concat(rooms_list, ",")
      end

      -- get all exits to any room in the previous set
      local q = string.format ("select fromuid, touid, dir, norecall, noportal from exits,rooms where rooms.uid = exits.touid and exits.fromuid in (%s) and exits.touid not in (%s) and exits.level <= %s order by length(exits.dir) asc",
                  table.concat(rooms_list,","), visited, mylevel+(mytier*10))
      local dcount = 0
      for row in db:nrows(q) do
         dcount = dcount + 1
         table.insert(rooms_list, fixsql(row.touid))
         -- ordering by length(dir) ensures that custom exits (always longer than 1 char) get
         -- used preferentially to normal ones (1 char)
         if ((bounce_portal ~= nil or target_type == "*") and row.noportal ~= 1) or ((bounce_recall ~= nil or target_type == "**") and row.norecall ~= 1) or row.touid == dst then
            type = ((row.touid == dst) and 1) or ( (((row.noportal == 1) and 2) or 0) + (((row.norecall == 1) and 4) or 0) )
            -- type 1 means walking to the destination is closer than bouncing
            -- type 2 means the bounce room allows recalling but not portalling
            -- type 4 means the bounce room allows portalling but not recalling
            -- type 0 means the bounce room allows both portalling and recalling
            destination = row.touid
            found = true
            found_depth = depth
         end -- if src
      end -- for select

      if dcount == 0 then
         return -- there is no path to a portalable or recallable room
      end -- if dcount
   end -- while

   if found == false then
      return
   end
   return destination, type, found_depth
end

valid_direction = {
   n = "n",
   s = "s",
   e = "e",
   w = "w",
   u = "u",
   d = "d",
   north = "n",
   south = "s",
   east = "e",
   west = "w",
   up = "u",
   down = "d",
}  -- end of valid_direction

-- try to detect when we send a movement command
function OnPluginSent (sText)
   if valid_direction [sText] then
      last_direction_moved = valid_direction [sText]
--    print ("Just moved", last_direction_moved)
      if current_room and rooms [current_room] then
         expected_exit = rooms [current_room].exits [last_direction_moved]
         if expected_exit then
            from_room = current_room
         end -- if
--     print ("expected exit for this direction is to room", expected_exit)
      end -- if
   end -- if
end -- function

function OnPluginConnect ()
   Send_GMCP_Packet("rawcolor on")
   mapper.cancel_speedwalk ()
   -- DoAfter (3, "look")  -- force mapper update
end -- OnPluginConnect

function OnPluginDisconnect ()
   mapper.cancel_speedwalk ()
end -- OnPluginConnect

function OnHelp (name, line, wildcards)
   local help_header = "                              [GMCP Mapper Help]"

   local help_index = [[
                           Mapper Help Index
=============================================================================
 mapper help               --> Show this list
 mapper help all           --> Show the entire list of all mapper commands
-----------------------------------------------------------------------------
 mapper help config        --> Commands for configuring the mapper
 mapper help exits         --> Commands for managing exits
 mapper help portals       --> Commands for managing portals
 mapper help searching     --> Commands for finding rooms
 mapper help exploring     --> Commands to aid exploring
 mapper help moving        --> Commands for moving between rooms
 mapper help utils         --> Other utilitarian commands
=============================================================================
]]

local help_config = [[

===== CONFIGURATION =============>

mapper quicklist [on/off]      --> ON will cause search results to display much
                                 > faster, but the results will not be sorted
                                 > by distance (default is off)
mapper shownotes [on/off]      --> ON will cause any notes in a room to display
                                 > automatically upon entering (default is off)
mapper backups <off/on>        --> Turn off or on automatic database backups
                                 > The default setting is on
mapper backups [un]compressed  --> Turn off or on database backup compression
                                 > The default setting is uncompressed (off)
mapper help                    --> This help
                                 > (or click the "?" button on the top right)
mapper zoom out                --> Zoom out
mapper zoom in                 --> Zoom in
mapper hide                    --> Hide map
mapper show                    --> Show map]]

local help_utils = [[

===== UTILITIES =================>

mapper backup                  --> Create new archived backup of your map

                                 > database in a db_backups directory,
                                 > preserving a few prior backups
mapper addnote                 --> Add a new note to the current room
mapper addnote <note>          --> Ditto, but skips the dialog
mapper purgezone <area>        --> Remove an area from the map database
mapper purgeroom               --> Purge the current room from the map database]]

   local help_exits = [[

===== EXIT ACTIONS ==============>

mapper cexits                  --> List known custom exits
mapper cexits <here/area>      --> List known custom exits only in this or
                                 > another area
mapper cexit <command>         --> Follow and link a custom exit
                                 > (ex: 'mapper cexit ride bucket')
                                 > To insert a pause during execution
                                 > of the cexit, use wait(<seconds>) as one
                                 > or more of the cexit moves
                                 > To stack commands use ;; as separator
                                 > to get around the line break parser
                                 > (ex: 'mapper cexit open south;;south')
mapper delete cexits           --> Remove the custom exits from this room
mapper purge cexits            --> Remove all custom exits
mapper cexit_wait <seconds>    --> Wait the given number of seconds instead of
                                 > the standard 2 when constructing the next
                                 > cexit (between 2 and 30)
mapper lockexit                --> Bring up the exit level-locking dialog
                                 > for the current room.]]

   local help_portals = [[

===== PORTAL ACTIONS ============>

mapper portals                 --> List known hand-held portals
                                 > Recall-flagged portals (below) show in red
mapper portal <command>        --> Link a hand-held portal alias to the current
                                 > room as a special exit from everwhere else
                                 > (ex: 'mapper portal recall' at recall).
                                 > To stack commands use ;; as separator
                                 > to get around the line break parser
                                 > (ex: 'mapper portal hold amulet;;enter').

+---- NORECALL/NOPORTAL ROOM ASSISTANCE -------------------------------------+
mapper portalrecall <index>    --> Flag/unflag a portal as using a recall or
                                 > home command, to avoid using it in
                                 > identified norecall rooms.
                                 > Find the indices with 'mapper portals'
mapper bounceportal <index>    --> Specifies which non-recall mapper portal
                                 > to bounce through when the path calculation
                                 > wants to recall or home from a
                                 > portal-friendly norecall room. For this to
                                 > work properly you must indicate which mapper
                                 > portals use recall or home with the
                                 > portalrecall command listed above.
                                 > Find the indices with 'mapper portals'
mapper bouncerecall <index>    --> Specifies which home/recall mapper portal to
                                 > bounce through when the path calculation
                                 > wants to portal from a recall-friendly
                                 > noportal room. You may only choose a portal
                                 > that has been marked as being a recall
                                 > portal using the portalrecall command listed
                                 > above.
                                 > Find the indices with 'mapper portals'
mapper bounceportal            --> Display the current bounce portal
mapper bouncerecall            --> Display the current bounce recall
mapper bounceportal clear      --> Clear the current bounce portal
mapper bouncerecall clear      --> Clear the current bounce recall
+----------------------------------------------------------------------------+

mapper portallevel <ind> <lvl> --> Change the level lock on a stored portal
                                 > Find the indices with 'mapper portals'
                                 > Do not manually account for tiers
mapper delete portal <command> --> Remove the specified hand-held portal alias
mapper delete portal #<index>  --> Remove a hand-held portal by its index
                                 > Find the indices with 'mapper portals'
mapper purge portals           --> Remove all hand-held portal aliases]]

   local help_searching = [[

===== SEARCHING =================>

mapper area <text>             --> Full-text search limited to the current zone
mapper find <text>             --> Full-text search the whole database
mapper list <text>             --> Find rooms without the known-path limits
                                 > of "area" and "find"

mapper notes                   --> Show nearby rooms that you marked with notes
mapper notes <here/area>       --> Ditto
mapper shops                   --> Show all shops/banks
mapper shops <here/area>       --> Ditto
mapper train                   --> Show all trainers
mapper train <here/area>       --> Ditto
mapper quest                   --> Show all quest-givers
mapper quest <here/area>       --> Ditto

mapper next                    --> Visit the next room in the most recent
                                 > list of results.
mapper where <room id>         --> Show directions to a room number]]

   local help_exploring = [[

===== EXPLORING =================>

mapper thisroom                --> Show details about the current room
mapper showroom <room id>      --> Draw the map as if you were standing in
                                 > a different room
mapper areas                   --> Show a list of all mapped areas
mapper areas <name>            --> Show a list of mapped areas partially
                                 > matching <name>
mapper unmapped                --> List unmapped exit counts for know areas
mapper unmapped <here/area>    --> List unmapped exits in this or another area]]

   local help_moving = [[

===== MOVING ====================>

mapper goto <room id>          --> Run to a room by its room number
mapper walkto <room id>        --> Run to a room by its room number without
                                 > using any mapper portals
mapper resume                  --> Initiate a new run to the previous target]]

   print("")
   print(help_header)
   print("+---------------------------------------------------------------------------+")
   if wildcards and wildcards[2] ~= "" then
      if wildcards[2] == "all" then
         print(help_config)
         print(help_exits)
         print(help_portals)
         print(help_searching)
         print(help_exploring)
         print(help_moving)
         print(help_utils)
      elseif wildcards[2] == "config" then
         print(help_config)
      elseif wildcards[2] == "exits" then
         print(help_exits)
      elseif wildcards[2] == "portals" then
         print(help_portals)
      elseif wildcards[2] == "searching" then
         print(help_searching)
      elseif wildcards[2] == "exploring" then
         print(help_exploring)
      elseif wildcards[2] == "moving" then
         print(help_moving)
      elseif wildcards[2] == "utils" then
         print(help_utils)
      end
   else
      print("")
      mapper.mapprint (world.GetPluginInfo (world.GetPluginID (), 3))
      print("")
      print(help_index)
   end
   print("")
   print("+---------------------------------------------------------------------------+")
   print("")
end

require "checkplugin"
function OnPluginListChanged ()
   do_plugin_check_now ("abc1a0944ae4af7586ce88dc", "support_repaint_buffer") -- check we have the repaint buffer plugin
   do_plugin_check_now ("3e7dedbe37e44942dd46d264", "support_GMCP_handler")    -- check we have GMCP plugin
   do_plugin_check_now ("462b665ecb569efbf261422f", "support_miniwin_z_order_monitor") -- check we have z order plugin
end -- OnPluginListChanged

function nilToStr(n)
   return (((n ~= nil) and tostring(n)) or "")
end

]]>
</script>
</muclient>
