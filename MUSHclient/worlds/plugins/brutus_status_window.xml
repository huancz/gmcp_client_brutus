<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on ètvrtek, duben 16, 2015, 11:18 odp. -->
<!-- MuClient version 4.73 -->

<!-- Plugin "brutus_group_window" generated by Plugin Wizard -->

<muclient>
<plugin
   name="brutus_status_window"
   author="huan"
   id="b3a9c0bdeef9394ff401358a"
   language="Lua"
   purpose="display group info in a window"
   save_state="y"
   date_written="2015-04-16 23:17:32"
   requires="4.73"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<script><![CDATA[

-- plugin provides status window framework - place for other plugins to display interesting
-- information outside of fast scrolling mud output buffer and not overwrite each other's
-- data. Each plugin that wants to use this should choose unique keyword for it's content
-- (or mupliple keywords), and priority how close to the top it wants it's data displayed
-- (doesn't have to be unique, but in case of priority collision the output order will be
-- undefined and may even switch places after updates)
--
-- example usage - set data (needs require "serialize" somewhere in the script)
-- CallPlugin('b3a9c0bdeef9394ff401358a', 'update_item', 'tickcounter', serialize.save_simple({
--    --                                                 ^^^^^^^^^^^^^ keyword for data
--    ["priority"] = 50,
--    ["styles"] = {
--       {
--          ["text"] = "time to tick: " .. counter,
--          ["textcolour"] = 0x00cb00,
--          ["backcolour"] = 0x0
--       }
--    }
-- }))
--
-- example usage - clear item (plugin is being uninstalled, group disbanded etc.)
-- CallPlugin('b3a9c0bdeef9394ff401358a', 'clear_item', 'tickcounter')
--
-- ["styles"] may be replaced with ["lines"] in case there are multiple lines to display.
-- Example:
--
-- "lines" = alternative to ["styles"], in case there are multiple lines to display. Syntax:
--   ["lines"] = {
--     {
--       { ["text"] = "line1...", ["textcolour"] = 0xff0000, ["backcolour"] = 255 },
--       { ["text"] = "...with green ending", ["textcolour"] = 0x00ff00, ["backcolour"] = 255 },
--     },
--     {
--       { ["text"] = "line2", ["textcolour"] = 0x00ff00 }
--     }
--   }

require "tprint"

local background_colour     = 0x000000
local border_color          = 0xcccccc
local default_width         = 1137
local default_height        = 100
local default_x             = 0
local default_y             = 552

local RESIZE_TAG_SIZE = 10
local MIN_WIDTH        = 40
local LEFT_MARGIN     = 10
local TOP_MARGIN      = 5

local statuslist = {}

function update_item(key, value)
  -- Note('external update, key ' .. key);
  local vtable = assert(loadstring('return ' .. value)());
  if (vtable["priority"] == nil) then
     return;
  end
  statuslist[key] = vtable
  -- Note(tprint(statuslist))
  Paint()
  -- Note('painted')
end

function clear_item(key)
  statuslist[key] = nil
  Paint()
end

-- function update_status_internal(name, output, wildcard, styles)
--   local s_name = name:split("_")
--   local s_priority = s_name[2] * 1
--   s_name = s_name[1]
--   statuslist[s_name] = {
--      ["priority"] = s_priority,
--      ["styles"] = styles
--   }
--   Paint()
-- end

-- local statuslist = {
  --[[ sample data:
  -- multiple lines, stash them into .lines property
  ["sanc_1"] = {
    ["priority"] = 51,
    ["lines"] = {
      {
        { ["text"] = "line1", ["textcolour"] = 0xff0000, ["backcolour"] = 255 },
      },
      {
        { ["text"] = "line2", ["textcolour"] = 0x00ff00 }
      }
    }
  },
  -- one line, belongs directly into .styles property
  ["sanc_2"] = {
    ["priority"] = 10,
    ["styles"] = {
      {
        ["text"] = "test1",
        ["textcolour"] = 0xff0000
      },
      {
        ["text"] = "test1",
        ["textcolour"] = 0xff0000
      }
    }
  }
  ]]--
-- }

function Paint_style_run_element(x, y, style_element)
   local len = WindowTextWidth(win, font_id, style_element.text)
   WindowRectOp(win, miniwin.rect_fill, x, y, x + len, y + font_height, style_element.backcolour)
   WindowText(win, font_id, style_element.text, x, y, 0, 0, style_element.textcolour)
   return len
end

function Paint_status_item(y, statusitem)
   if (statusitem.styles) then
      local x = 5
      for _, style in ipairs (statusitem.styles) do
         x = x + Paint_style_run_element(x, y, style)
      end
      y = y + font_height
   else
      for _, line in ipairs (statusitem.lines) do
         local x = 5
         for _, style in ipairs (line) do
            x = x + Paint_style_run_element(x, y, style)
         end
         y = y + font_height
      end
   end
   return y
end

function Paint()
   WindowRectOp(win, 2, 2,2,-2,-2,background_colour) -- blank
   local y = TOP_MARGIN

   local slist_ordered_keys = {}
   for k,v in pairs(statuslist) do
     table.insert(slist_ordered_keys, k)
   end
   table.sort(slist_ordered_keys, function(l, r)
     return (statuslist[l]['priority'] < statuslist[r]['priority'])
   end)

   for _,v in ipairs(slist_ordered_keys) do
     local s = statuslist[v];
     y = Paint_status_item(y, s)
   end

   -- draw the resize widget bottom right corner.
   WindowLine(win, width-3, height-2, width-2, height-3, 0xffffff, 0, 2)
   WindowLine(win, width-4, height-2, width-2, height-4, 0x696969, 0, 1)
   WindowLine(win, width-6, height-2, width-2, height-6, 0xffffff, 0, 2)
   WindowLine(win, width-7, height-2, width-2, height-7, 0x696969, 0, 1)
   WindowLine(win, width-9, height-2, width-2, height-9, 0xffffff, 0, 2)
   WindowLine(win, width-10, height-2, width-2, height-10, 0x696969, 0, 1)
   WindowLine(win, width-12, height-2, width-2, height-12, 0xffffff, 0, 2)
   WindowLine(win, width-13, height-2, width-2, height-13, 0x696969, 0, 1)

   BroadcastPlugin (999, "repaint")
end -- Paint





--[[
--  big and ugly copy/paste from brutus_health_bars.xml. Most of it should be
--  likely moved into some "window" library
--]]

require "movewindow"
require "gauge"
require "gmcphelper"
require "serialize"
require "string"

-- Variables not saved.
startx     = ""
starty     = ""
posx       = ""
posy       = ""
hotspot_id = ""
page_built = false

-- functions for handling brutus color codes
dofile (GetPluginInfo (GetPluginID(), 20) .. "brutus_colors.lua")

-- remove trailing whitespace from string.
-- http://en.wikipedia.org/wiki/Trim_(8programming)
function rtrim(s)
  local n = #s
  while n > 0 and s:find("^%s", n) do n = n - 1 end
  return s:sub(1, n)
end

--Written for 5.0; could be made slightly cleaner with 5.1
--Splits a string based on a separator string or pattern;
--returns an array of pieces of the string.
--(May optionally supply a table as the third parameter which will be filled
--with the results.)
function string:split( inSplitPattern, outResults )
  if not outResults then
    outResults = { }
    end
  local theStart = 1
  local theSplitStart, theSplitEnd = self:find(inSplitPattern, theStart )
  while theSplitStart do
    table.insert( outResults, self:sub(theStart, theSplitStart-1 ) )
    theStart = theSplitEnd + 1
    theSplitStart, theSplitEnd = self:find(inSplitPattern, theStart )
  end
  table.insert( outResults, self:sub(theStart ) )
  return outResults
end

string.lpad = function(str, len, char)
   str = tostring(str)
   if char == nil then char = ' ' end
   return string.rep(char, len - #str) .. str
end

string.rpad = function(str, len, char)
   str = tostring(str)
   if char == nil then char = ' ' end
   return str .. string.rep(char, len - #str)
end

-- right click menu
function right_click_menu ()
   menustring ="!Change Font|"
   menustring = menustring .. "<|-|Bring To Front|Send To Back|-|>(In case of emergency)|Reduce Size|<|"

   result = WindowMenu (win,
      WindowInfo (win, 14),  -- x position
      WindowInfo (win, 15),   -- y position
      menustring) -- content
   if result ~= "" then
      numResult = tonumber(result)
      if numResult == 1 then
         -- change font
         wanted_font = utils.fontpicker (font_name, font_size) --font dialog
         if wanted_font then
            font_name = wanted_font.name
            font_size = wanted_font.size
         end
      elseif numResult == 2 then
         -- bring to front
         CallPlugin("462b665ecb569efbf261422f","boostMe", win)
      elseif numResult == 3 then
         -- send to back
         CallPlugin("462b665ecb569efbf261422f","dropMe", win)
      elseif numResult == 4 then
         -- reduce size
         font_name = default_font_name
         font_size = default_font_size
         height = ((line_height+1)*1)+(TOP_MARGIN*2)
         width = MIN_WIDTH
      end -- if

      OnPluginSaveState()
      OnPluginInstall()
   end
end -- right_click_menu

--=================================================================================
-- Called when plugin receives telnet data - main entry point for actually running
-- the plugin... except that this plugin gets by with triggers only, no need for
-- GMCP.
--=================================================================================
--[[
function OnPluginBroadcast (msg, id, name, text)

   -- Look for GMCP handler.
   if (id == '3e7dedbe37e44942dd46d264') then
      if (text == 'reload') then
         -- invalidate current data
         page_built = false
         return
      end

      if (text == "char.base" or text == "char.vitals" or text == "char.status" or text == "char.maxstats") then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char")

         luastmt = "gmcpdata = " .. gmcparg
         assert (loadstring (luastmt or "")) ()

         if page_built ~= true then
            -- draw edge frame again, just in case the text has overlapped the border
            WindowRectOp (win, 1, 0, 0, 0, 0, border_color, 15)
            WindowRectOp (win, 1, 1, 1, -1, -1, 0x777777, 15)
         end
         page_built = true
         Paint()
      end
   elseif (id == "462b665ecb569efbf261422f" and msg==996 and text == "re-register z") then
      CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", win)
   end
end
]]--


---------------------------------------------------------------------------------
-- Called as the window is dragged around. This function and those below are
-- only 'handlers' because they are set in WindowAddHotSpot
---------------------------------------------------------------------------------
function ResizeMoveCallback()
   if GetPluginVariable("c293f9e7f04dde889f65cb90", "lock_down_miniwindows") == "1" then
      return
   end
   posx, posy = WindowInfo (win, 17), WindowInfo (win, 18)
   width = width + posx - startx
   height = height + posy - starty
   startx = posx
   starty = posy
   if (width < MIN_WIDTH) then
      width = MIN_WIDTH
      startx = windowinfo.window_left+width
   elseif (windowinfo.window_left+width > GetInfo(281)) then
      width = GetInfo(281)-windowinfo.window_left
      startx = GetInfo(281)
   end

   if (utils.timer() - lastRefresh > 0.0333) then
      SetUpHotspotsAndDraw(false)
      lastRefresh = utils.timer()
   end
end

lastRefresh = 0

---------------------------------------------------------------------------------
-- Called after the resize widget is released.
---------------------------------------------------------------------------------
function ResizeReleaseCallback()
   orig_width = 0
   SetUpHotspotsAndDraw(false)
end

---------------------------------------------------------------------------------
-- Called when mouse button is pressed on hotspot.
---------------------------------------------------------------------------------
function MouseDown(flags, hotspot_id)
   if (hotspot_id == "resize") then
      startx, starty = WindowInfo (win, 17), WindowInfo (win, 18)
   end
end

---------------------------------------------------------------------------------
-- Called when mouse moved away from hotspot. Doesn't really apply for draggables.
---------------------------------------------------------------------------------
function CancelMouseDown(flags, hotspot_id)
end

---------------------------------------------------------------------------------
-- Called when mouse button released on hotspot.
---------------------------------------------------------------------------------
function MouseUp(flags, hotspot_id, win)
   if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      right_click_menu()
   end
   return true
end

function LeftClickOnly(flags, hotspot_id, win)
   if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      return true
   end
   return false
end

---------------------------------------------------------------------------------
-- Called when plugin is saved - store our variables for next time.
---------------------------------------------------------------------------------
function OnPluginSaveState ()
   -- save window current location for next time
   movewindow.save_state (win)
   SetVariable ("enabled", tostring (GetPluginInfo (GetPluginID (), 17)))
   SetVariable ("background_colour", background_colour)
   SetVariable ("width", (((orig_width ~= 0) and orig_width) or width))
   SetVariable ("height", height)
   SetVariable ("font_name", font_name)
   SetVariable ("font_size", font_size)
end -- OnPluginSaveState

function OnPluginClose()
   OnPluginDisable()
   WindowDelete(win)
end

function OnPluginDisable ()
   OnPluginSaveState()
   WindowShow( win, false )
end --  OnPluginDisable

function OnPluginEnable ()
   WindowShow (win, true)
   OnPluginSaveState()
end -- OnPluginEnable


win = GetPluginID()
require "checkplugin"
function OnPluginListChanged ()
   do_plugin_check_now ("abc1a0944ae4af7586ce88dc", "support_repaint_buffer") -- check we have the repaint buffer plugin
   --do_plugin_check_now ("3e7dedbe37e44942dd46d264", "support_GMCP_handler")    -- check we have GMCP plugin
   do_plugin_check_now ("462b665ecb569efbf261422f", "support_miniwin_z_order_monitor") -- check we have z order plugin
end -- OnPluginListChanged

orig_width = 0
function OnPluginWorldOutputResized()
   if installed == true then
      orig_width = math.max(width, orig_width)
      width = math.min(orig_width, GetInfo(281)-windowinfo.window_left)
      SetUpHotspotsAndDraw(false)
   end
end

function OnPluginInstall()
   background_colour = tonumber (GetVariable ("background_colour")) or background_colour
   -- make window so I can grab the font info
   WindowCreate (win, 600, 600, 1, 1, 0, 0, background_colour)

   font_id = "statmon_font"

   local fonts = utils.getfontfamilies ()

   -- if not there already, add it
   if not fonts.Dina then
      AddFont (GetInfo (66) .. "\\Dina.fon")
      fonts = utils.getfontfamilies ()
   end -- if Dina not installed

   if fonts ["Dina"] then
      default_font_size = 8
      default_font_name = "Dina"    -- the actual font
   elseif fonts["Courier New"] then
      default_font_size = 9
      default_font_name = "Courier New"
   else
      default_font_size = 9
      default_font_name = "Lucida Console"
   end -- if

   font_name = GetVariable("font_name") or default_font_name
   font_size = tonumber(GetVariable("font_size")) or default_font_size

   --- Load the fonts into the temp window.
   WindowFont (win, font_id, font_name, font_size, false, false, false, false) -- normal font

   --- Grab font size settings.
   font_height = WindowFontInfo (win, font_id, 1) -  WindowFontInfo (win, font_id, 4) + 1 -- height
   font_width  = WindowFontInfo (win, font_id, 6)  -- avg width
   line_height = font_height + 1

   --- install the window movement handler, get back the window position.
   windowinfo  = movewindow.install (win, miniwin.pos_top_right, miniwin.create_absolute_location, false, nil, {mouseup=MouseUp, mousedown=LeftClickOnly, dragmove=LeftClickOnly, dragrelease=LeftClickOnly},{x=default_x, y=default_y})

   MIN_WIDTH = math.max(40, WindowTextWidth(win, font_id, "WWWWW:")+LEFT_MARGIN*2)

   width = tonumber(GetVariable("width")) or default_width
   width = math.max(width, MIN_WIDTH)
   height = tonumber(GetVariable("height")) or default_height
   height = math.max(height, line_height + 2 * TOP_MARGIN) -- always reserve space for at least one line

   --- Setup the window.
   SetUpHotspotsAndDraw(true)
   -- if IsConnected() then
   --    Send_GMCP_Packet("request char")
   -- end

   -- if disabled last time, stay disabled
   if GetVariable ("enabled") == "false" then
      ColourNote ("yellow", "", "Warning: Plugin " .. GetPluginName ().. " is currently disabled.")
      check (EnablePlugin(GetPluginID (), false))
      return
   end -- they didn't enable us last time

   OnPluginSaveState()
   installed = true
end

--=================================================================================
-- Called by OnPluginInstall, but also by redraw routine to refresh the screen
-- and (if the first time) add the resizer tag, otherwise move the resizer relative
-- to the main window.
--=================================================================================
function SetUpHotspotsAndDraw(firstTime)
   if (firstTime == true) then
      check (WindowCreate (win,
            windowinfo.window_left, windowinfo.window_top,   -- left, top (auto-positions)
            width,     -- width
            height,  -- height
            windowinfo.window_mode,       -- auto-position: middle right
            windowinfo.window_flags,  -- flags
            background_colour) )
      -- Add handler for resizing
      WindowAddHotspot(win, "resize", width-RESIZE_TAG_SIZE, height-RESIZE_TAG_SIZE, width, height, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 6, 0)
      WindowDragHandler(win, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
      CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", win)
      WindowShow (win, true)
   else
      -- everything has already been made
      -- just move them back into place
      WindowResize(win, width, height, background_colour)
      WindowMoveHotspot(win, "resize", width-RESIZE_TAG_SIZE, height-RESIZE_TAG_SIZE, width, height)
   end

   -- Add the drag handler so they can move the window around
   movewindow.add_drag_handler (win, 0, 0, 0, 0)

   -- draw edge frame.
   WindowRectOp (win, 1, 0, 0, 0, 0, border_color, 15)
   WindowRectOp (win, 1, 1, 1, -1, -1, 0x777777, 15)

   Paint()
end

-------------------------------------------------------------------------------
--- Calculate width of a line of styled text without drawing it.
-------------------------------------------------------------------------------
function styleWidth(styles)
   local s = ""
   for _,w in ipairs (styles) do
      s = s .. w.text
   end
   return WindowTextWidth(win,font_id,s)
end -- styleWidth

]]></script>
</muclient>
<!-- vim: sw=3 et ts=3 syntax=lua -->
